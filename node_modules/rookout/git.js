"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _wrapRegExp() { _wrapRegExp = function (re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { var i = g[name]; if ("number" == typeof i) groups[name] = result[i];else { for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++; groups[name] = result[i[k]]; } return groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

const path = require('path');

const fs = require('fs');

const GIT_FOLDER = '.git';
const GIT_HEAD = 'HEAD';
const GIT_CONFIG = 'config';

class git {
  static isGit(pathToCheck) {
    return fs.existsSync(path.join(pathToCheck, GIT_FOLDER));
  }

  static findRoot(pathToCheck) {
    if (this.isGit(pathToCheck)) {
      return pathToCheck;
    }

    var nextPath = path.dirname(pathToCheck);

    if (nextPath !== pathToCheck) {
      return this.findRoot(nextPath);
    }

    return "";
  }

  static getRevision(pathToCheck) {
    return this.followSymLinks(path.join(pathToCheck, GIT_FOLDER), GIT_HEAD);
  }

  static getRemoteOrigin(pathToCheck) {
    const content = fs.readFileSync(path.join(pathToCheck, GIT_FOLDER, GIT_CONFIG), 'utf-8');
    const matches = content.match( /*#__PURE__*/_wrapRegExp(/\[remote "origin"\]\n\s*url\s*=\s(\S*)/, {
      url: 1
    }));

    if (matches.groups !== undefined && matches.groups.url !== undefined) {
      return matches.groups.url;
    } else {
      return "";
    }
  }

  static followSymLinks(root, link) {
    var content = fs.readFileSync(path.join(root, link), 'utf-8');

    if (content.startsWith("ref:")) {
      var nextLink = content.split(' ')[1].trim();
      return this.followSymLinks(root, nextLink);
    } else {
      return content.trim();
    }
  }

}

exports.default = git;