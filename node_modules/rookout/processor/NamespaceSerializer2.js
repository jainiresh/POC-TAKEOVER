"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("../logger");

var _NamespaceSerializerBase = _interopRequireDefault(require("./NamespaceSerializerBase"));

var _Variant2Writer = _interopRequireDefault(require("./Variant2Writer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const variant_pb = require('../protobuf/variant_pb');

const timestamp_pb = require('google-protobuf/google/protobuf/timestamp_pb');

const util = require("util");

class NamespaceSerializer2 extends _NamespaceSerializerBase.default {
  constructor() {
    super(true);
  }

  dumps(namespace, logErrors = true) {
    let variant2Writer = new _Variant2Writer.default();
    this.dump(namespace, variant2Writer, logErrors);
    return variant2Writer;
  }

  dump(namespace, variant2Writer, logErrors = true) {
    const position = variant2Writer.getPosition();

    try {
      this.dumpUnsafe(namespace, variant2Writer, logErrors);
    } catch (e) {
      const message = "Failed to serialize namespace";
      this.resetPosition(variant2Writer, position);
      this.safeError(variant2Writer, message, e, logErrors);
    }
  }

  dumpContainerNamespace(namespace, variant2Writer, logErrors) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_NAMESPACE);
    const self = this;
    let names = [];

    for (let key of Object.keys(namespace.namespaces)) {
      names.push(this.getStringIndexInCache(key));
      variant2Writer.writeAttributeValues(namespace.namespaces[key], (object, variant2Writer) => {
        self.dump(object, variant2Writer, logErrors);
      });
    }

    variant2Writer.writeAttributeNamesInCache(names);
  }

  dumpLogRecordNamespace(namespace, variant2Writer, logErrors) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIVETAIL);
    let variant = new variant_pb.Variant.LiveTailMessage();
    namespace.dumpToVariant(variant);
    variant2Writer.writeLiveTailValue(variant, (livetail, writer) => {
      variant_pb.Variant.LiveTailMessage.serializeBinaryToWriter(livetail, writer);
    });
  }

  dumpJSObject(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    const position = variant2Writer.getPosition();

    try {
      this.unsafeDumpJSObject(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
    } catch (e) {
      const message = "Failed to serialize object";
      this.resetPosition(variant2Writer, position);
      this.safeError(variant2Writer, message, e, logErrors);
    }
  }

  unsafeDumpJSObject(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    if (undefined === obj) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_UNDEFINED);
      return;
    }

    if (null === obj) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_NONE);
      return;
    }

    this.dumpOriginalType(obj, variant2Writer);

    if (obj === true || obj === false) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LONG);
      variant2Writer.writeLongValue(obj ? 1 : 0);
      return;
    }

    if (Number.isInteger(obj)) {
      if (obj >= 0x7fffffffffffffff || obj < -0x7fffffffffffffff) {
        this.dumpDouble(obj, variant2Writer);
      } else {
        variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LONG);
        variant2Writer.writeLongValue(obj);
      }

      return;
    }

    if (this.isFloat(obj) || Number.isNaN(obj)) {
      this.dumpDouble(obj, variant2Writer);
      return;
    }

    if (typeof obj === 'string' || obj instanceof String) {
      this.dumpString(obj, variant2Writer, dumpConfig);
      return;
    }

    if (obj instanceof Date) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_TIME);
      let date = new timestamp_pb.Timestamp();

      if (isNaN(obj.getTime())) {
        // date is not valid
        obj = new Date(0);
      }

      date.fromDate(obj);
      variant2Writer.writeTimeValue(date, (date, writer) => {
        timestamp_pb.Timestamp.serializeBinaryToWriter(date, writer);
      });
      return;
    }

    if (Array.isArray(obj) || obj instanceof Buffer) {
      this.dumpArray(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (obj instanceof Set) {
      this.dumpSet(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (obj instanceof Map) {
      this.dumpMap(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (obj instanceof ArrayBuffer) {
      this.dumpArray(new Uint8Array(obj), variant2Writer, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (obj instanceof Error) {
      this.dumpException(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (typeof obj === 'function') {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_CODE_OBJECT);
      variant2Writer.writeCodeValues([obj], (obj, writer) => {
        writer.writeString(1, obj.name);
      });
      return;
    }

    this.dumpUserClass(obj, variant2Writer, currentDepth, dumpConfig, logErrors);
  }

  dumpString(obj, variant2Writer, dumpConfig) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_STRING);

    if (obj.length > dumpConfig.maxString) {
      variant2Writer.writeOriginalSize(obj.length);
      variant2Writer.writeBytesIndexInCache(this.getStringIndexInCache(obj.substring(0, dumpConfig.maxString)));
    } else {
      variant2Writer.writeBytesIndexInCache(this.getStringIndexInCache(obj));
    }
  }

  dumpOriginalType(obj, variant2Writer) {
    let type;

    try {
      type = obj.__proto__.constructor.name;
    } catch (e) {
      type = typeof obj;
    }

    variant2Writer.writeTypeIndexInCache(this.getStringIndexInCache(type));
  }

  static getObjectType(obj) {
    let type;

    try {
      type = obj.__proto__.constructor.name;
    } catch (e) {
      type = typeof obj;
    }

    return type;
  }

  dumpUserClass(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    const symbols = Object.getOwnPropertySymbols(obj);
    const objectKeys = Object.keys(obj);
    const objectWidth = symbols.length + objectKeys.length;
    const childrenDepth = currentDepth + (objectWidth >= dumpConfig.maxWidth ? 2 : 1);

    if (childrenDepth >= dumpConfig.maxDepth) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_OBJECT, objectWidth > 0);
      return;
    }

    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_OBJECT);
    const self = this;
    let names = [];

    for (let key of objectKeys) {
      if (obj[key] === obj) {
        continue;
      } // If it's an Array, ignore it's index attributes


      if (Array.isArray(obj) && parseInt(key).toString() === key) {
        continue;
      }

      names.push(this.getStringIndexInCache(key));
      variant2Writer.writeAttributeValues(key, (object, variant2Writer) => {
        if ('get' in Object.getOwnPropertyDescriptor(obj, key)) {
          variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_DYNAMIC);
        } else {
          self.dumpJSObject(obj[key], variant2Writer, childrenDepth, dumpConfig, logErrors);
        }
      });
    }

    for (let index in symbols) {
      let symbol = symbols[index];
      let symbolName = symbol.toString();
      names.push(this.getStringIndexInCache(symbolName));
      variant2Writer.writeAttributeValues(symbol, (object, variant2Writer) => {
        self.dumpJSObject(obj[symbol], variant2Writer, childrenDepth, dumpConfig, logErrors);
      });
    }

    variant2Writer.writeAttributeNamesInCache(names);
  }

  dumpDouble(obj, writer) {
    writer.writeVariantType(variant_pb.Variant.Type.VARIANT_DOUBLE);
    writer.writeDoubleValue(obj);
  }

  dumpArray(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    const itemDepth = currentDepth + 1;

    if (itemDepth >= dumpConfig.maxCollectionDepth && obj.length > 0) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIST, true);
      return;
    }

    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    const countToWrite = Math.min(obj.length, dumpConfig.maxWidth);

    if (countToWrite !== obj.length) {
      variant2Writer.writeOriginalSize(obj.length);
    }

    const self = this;

    for (let i = 0; i < countToWrite; ++i) {
      variant2Writer.writeCollectionValues(i, () => {
        self.dumpJSObject(obj[i], variant2Writer, currentDepth + 1, dumpConfig, logErrors);
      });
    }
  }

  dumpSet(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    const itemDepth = currentDepth + 1;

    if (itemDepth >= dumpConfig.maxCollectionDepth && obj.size > 0) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIST, true);
      return;
    }

    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    const countToWrite = Math.min(obj.size, dumpConfig.maxWidth);

    if (countToWrite !== obj.size) {
      variant2Writer.writeOriginalSize(obj.size);
    }

    const self = this;
    let i = 0;

    for (let item of obj) {
      if (i >= countToWrite) {
        break;
      }

      variant2Writer.writeCollectionValues(i, () => {
        self.dumpJSObject(item, variant2Writer, currentDepth + 1, dumpConfig, logErrors);
      });
      ++i;
    }
  }

  dumpMap(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    const itemDepth = currentDepth + 1;

    if (itemDepth >= dumpConfig.maxCollectionDepth && obj.size > 0) {
      variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_MAP, true);
      return;
    }

    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_MAP);
    const countToWrite = Math.min(obj.size, dumpConfig.maxWidth);

    if (countToWrite !== obj.size) {
      variant2Writer.writeOriginalSize(obj.size);
    }

    const self = this;
    let i = 0;

    for (let item of obj) {
      if (i >= countToWrite) {
        break;
      }

      variant2Writer.writeCollectionKeys(i, () => {
        self.dumpJSObject(item[0], variant2Writer, currentDepth + 1, dumpConfig, logErrors);
      });
      variant2Writer.writeCollectionValues(i, () => {
        self.dumpJSObject(item[1], variant2Writer, currentDepth + 1, dumpConfig, logErrors);
      });
      ++i;
    }
  }

  dumpException(obj, variant2Writer, currentDepth, dumpConfig, logErrors) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_OBJECT);
    const self = this;
    let names = [];
    names.push(this.getStringIndexInCache('message'));
    variant2Writer.writeAttributeValues(obj.message, (message, variant2Writer) => {
      self.dumpJSObject(message, variant2Writer, currentDepth + 1, dumpConfig, logErrors);
    });

    if (!dumpConfig.skipStacktrace) {
      names.push(this.getStringIndexInCache('stack'));
      variant2Writer.writeAttributeValues(obj.stack, (stack, writer) => {
        self.dumpJSObject(stack, writer, currentDepth + 1, dumpConfig, logErrors);
      });
    }

    variant2Writer.writeAttributeNamesInCache(names);
  }

  dumpListNamespace(namespace, variant2Writer, logErrors) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    const self = this;

    for (let item of namespace.list) {
      variant2Writer.writeCollectionValues(item, (item, variant2Writer) => {
        self.dump(item, variant2Writer, logErrors);
      });
    }
  }

  dumpInspectorTracebackNamespace(namespace, variant2Writer) {
    let self = this;
    namespace.streamDump(variant2Writer, str => self.getStringIndexInCache(str));
  }

  safeError(variant2Writer, message, exception, logErrors) {
    variant2Writer.writeVariantType(variant_pb.Variant.Type.VARIANT_ERROR);

    if (logErrors) {
      // Todo - send warning when UserWarnings will be static
      _logger.logger.exception(message, exception);
    }
  }

  resetPosition(variant2Writer, newPosition) {
    // Finish the block in progress
    let lastBlock = variant2Writer.encoder_.end();
    variant2Writer.blocks_.push(lastBlock);
    variant2Writer.totalLength_ += lastBlock.length; // Check position is within bounds

    if (newPosition.totalLength < 0 || newPosition.totalLength > variant2Writer.totalLength_) {
      throw new Error(util.format("Can't reset to a position beyond the write boundaries!, newPosition: %d, totalLength: %d", newPosition.totalLength, variant2Writer.totalLength_));
    } // Remove blocks until we are below the target


    while (variant2Writer.totalLength_ > newPosition.totalLength) {
      lastBlock = variant2Writer.blocks_.pop();
      variant2Writer.totalLength_ -= lastBlock.length;
    } // Slice the last block down to the desired size and put it back into active state


    const newBlockSize = newPosition.totalLength - variant2Writer.totalLength_;
    variant2Writer.encoder_.buffer_ = lastBlock.slice(0, newBlockSize); // Pop all stale bookmarks
    // NOTE: We remove the bookmark for this position as well, which may be the wrong thing to do in some cases

    while (variant2Writer.bookmarks_.length > newPosition.bookmarksCount) {
      variant2Writer.bookmarks_.pop();
    }
  }

}

exports.default = NamespaceSerializer2;