"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ContainerNamespace = _interopRequireDefault(require("./namespaces/ContainerNamespace"));

var _JSObjectNamespace = _interopRequireDefault(require("./namespaces/JSObjectNamespace"));

var _ListNamespace = _interopRequireDefault(require("./namespaces/ListNamespace"));

var _InspectorTracebackNamespace = require("./namespaces/InspectorTracebackNamespace");

var _LogRecordNamespace = _interopRequireDefault(require("./namespaces/LogRecordNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class NamespaceSerializerBase {
  constructor(useStringCache = false) {
    this.useStringCache = useStringCache;
    this.stringCache = {};

    if (useStringCache) {
      // Lock the 0 index since some variant will have no originalType (container for example)
      this.stringCache[""] = 0;
    }

    this.estimatedPendingBytes = 0;
  }

  dumpUnsafe(namespace, variantHandler, logErrors) {
    if (namespace instanceof _ContainerNamespace.default) {
      this.dumpContainerNamespace(namespace, variantHandler, logErrors);
    } else if (namespace instanceof _LogRecordNamespace.default) {
      this.dumpLogRecordNamespace(namespace, variantHandler, logErrors);
    } else if (namespace instanceof _JSObjectNamespace.default) {
      this.dumpJSObject(namespace.obj, variantHandler, 0, namespace.dumpConfig, logErrors);
    } else if (namespace instanceof _ListNamespace.default) {
      this.dumpListNamespace(namespace, variantHandler, logErrors);
    } else if (namespace instanceof _InspectorTracebackNamespace.InspectorTracebackNamespace) {
      this.dumpInspectorTracebackNamespace(namespace, variantHandler);
    } else {
      throw new TypeError("Does not support serializing this type: " + typeof namespace);
    }
  }

  dumpContainerNamespace(namespace, variantHandler, logErrors) {
    throw new Error("dumpContainerNamespace is not implemented!");
  }

  dumpLogRecordNamespace(namespace, variantHandler, logErrors) {
    throw new Error("dumpLogRecordNamespace is not implemented!");
  }

  dumpJSObject(namespace, variantHandler, currentDepth, dumpConfig, logErrors) {
    throw new Error("dumpJSObjectNamespace is not implemented!");
  }

  dumpListNamespace(namespace, variantHandler, logErrors) {
    throw new Error("dumpListNamespace is not implemented!");
  }

  dumpInspectorTracebackNamespace(namespace, variantHandler) {
    throw new Error("dumpInspectorTracebackNamespace is not implemented!");
  }

  getStringCache() {
    return this.stringCache;
  }

  getEstimatedPendingBytes() {
    return this.estimatedPendingBytes;
  }

  getStringIndexInCache(str) {
    if (str in this.stringCache) {
      return this.stringCache[str];
    } // We estimate each character is one byte in utf-8 and overhead is 5 bytes


    this.estimatedPendingBytes += str.length + 5;
    let currentSize = Object.keys(this.stringCache).length;
    this.stringCache[str] = currentSize;
    return currentSize;
  }

  isFloat(n) {
    try {
      // This seems to throw sometimes :(
      return n === +n && n !== (n | 0);
    } catch (e) {
      return false;
    }
  }

}

exports.default = NamespaceSerializerBase;