"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MSToNS = MSToNS;
exports.NanosecToMillisec = NanosecToMillisec;
exports.StringUtils = void 0;
exports.canonizeFileName = canonizeFileName;
exports.conditionalRequire = conditionalRequire;
exports.conditionalResolve = conditionalResolve;
exports.crc32 = crc32;
exports.getEnv = getEnv;
exports.getTimeInNanoseconds = getTimeInNanoseconds;
exports.initUtils = initUtils;
exports.isBooleanValue = isBooleanValue;
exports.nodeUnref = nodeUnref;
exports.quietPrint = quietPrint;
exports.sha256 = sha256;

var _hashWasm = require("hash-wasm");

const path = require('path');

const process = require('process');

const config = require('./config');

class StringUtils {
  static trim(string) {
    return string.replace(/^\s+|\s+$/g, '');
  }

  /***
   * Strip a string on both ends from specific chars
   * @param string
   * @param chars
   */
  static strip(string, chars) {
    const charsArray = [];

    for (let char of chars) {
      switch (char) {
        case "}":
        case "{":
        case "]":
        case "[":
          charsArray.push("\\" + char);
          break;

        default:
          charsArray.push(char);
      }
    }

    const re = RegExp(`^[${charsArray.join("")}]+|[${charsArray.join("")}]+$`, "g");
    return string.replace(re, '');
  }

}

exports.StringUtils = StringUtils;

function getEnv(envName, defaultValue) {
  return process.env[envName] || defaultValue;
}

const CANONIZE_REGEX = /[\\\/]/g;

function canonizeFileName(filename) {
  return path.normalize(filename.replace(CANONIZE_REGEX, '/'));
}

function getTimeInNanoseconds() {
  return Number(process.hrtime.bigint());
}

function MSToNS(milliseconds) {
  return milliseconds * 1000000;
}

function NanosecToMillisec(nanoseconds) {
  return nanoseconds / 1000000;
}

function conditionalRequire(filename) {
  try {
    return require(`${filename}`);
  } catch (err) {
    return undefined;
  }
}

function conditionalResolve(filename) {
  try {
    return require.resolve(`${filename}`);
  } catch (err) {
    return undefined;
  }
}

let hasher = null;
let crcer = null;
let hasherPromise = null;
let crcerPromise = null;

function initUtils() {
  return new Promise(resolve => {
    if (hasherPromise === null) {
      hasherPromise = (0, _hashWasm.createSHA256)().then(v => hasher = v);
    }

    if (crcerPromise === null) {
      crcerPromise = (0, _hashWasm.createCRC32)().then(v => crcer = v);
    }

    Promise.all([hasherPromise, crcerPromise]).then(() => resolve());
  });
}

function sha256(value) {
  hasher.init();
  hasher.update(value);
  return hasher.digest('hex');
}

function crc32(value) {
  crcer.init();
  crcer.update(value);
  return crcer.digest('hex');
}

function quietPrint(msg) {
  if (!config.LoggingConfiguration.QUIET) {
    console.log(msg);
  }
}

function nodeUnref(obj) {
  if (obj !== null) {
    obj.unref();
  }
}

const trueValues = ['y', 'Y', 'yes', 'Yes', 'YES', 'true', 'True', 'TRUE', '1', true];

function isBooleanValue(value) {
  return trueValues.indexOf(value) !== -1;
}