"use strict";

var _logger = require("../logger");

var _SourceMapUrls = require("./SourceMapUrls");

var _InspectorDebug = require("./InspectorDebug");

var _config = _interopRequireDefault(require("../config"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  This is a file used to get all the sources maps of a project.
  It is based on a deprecated library called `source-map-resolve`.
  `SourceMapUrls.js` is a slimmer version of said library.
  We had to change the library because we ran into a problem where it didn't get all source maps if their URLs were found in the same file.
*/
// If you need to understand this regex please read: https://rookout.atlassian.net/wiki/spaces/RND/pages/2456485893/The+SourceMappingURL+Regex
const sourceMappingURLRegex = /\/[\/*]#\s*sourceMappingURL=\s*(\S+)\s*(?:\*\/|(?<!\*\/)$|(?<!\*\/)\n)/g;
var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
/**
 * The media type for JSON text is application/json.
 *
 * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
 *
 * `text/json` is non-standard media type
 */

var jsonMimeTypeRegex = /^(?:application|text)\/json$/; // A function to get all URLs from a single file
// The function `matchAll` is not supported before nodejs version 12
// so we are using `exec` instead.

function oldGetAllUrls(code) {
  let match;
  const allSourcesUrl = [];

  do {
    match = sourceMappingURLRegex.exec(code);

    if (match) {
      allSourcesUrl.push(match[1] || match[2] || "");
    }
  } while (match);

  sourceMappingURLRegex.lastIndex = 0;
  return allSourcesUrl;
} // A function to get all URLs from a single file
// `matchAll` is supported from nodejs version 12.


function getAllUrls(code) {
  const allSourcesUrl = [];
  const matches = code.matchAll(sourceMappingURLRegex);

  for (let m of matches) {
    allSourcesUrl.push(m[1] || "");
  }

  return allSourcesUrl;
} // Creates a new object containing the relevant data for a source map


function parseSourceMappingUrl(url, codeUrl) {
  codeUrl = (0, _SourceMapUrls.convertWindowsPath)(codeUrl);

  if (!url) {
    return null;
  } // inline sources


  var dataUri = url.match(dataUriRegex);

  if (dataUri) {
    var mimeType = dataUri[1] || "text/plain";
    var lastParameter = dataUri[2] || "";
    var encoded = dataUri[3] || "";
    var data = {
      sourceMappingURL: url,
      url: null,
      sourcesRelativeTo: codeUrl,
      map: encoded
    };

    if (!jsonMimeTypeRegex.test(mimeType)) {
      var error = new Error("Unuseful data uri mime type: " + mimeType);
      error.sourceMapData = data;
      throw error;
    }

    try {
      data.map = (0, _SourceMapUrls.parseMapToJSON)(lastParameter === ";base64" ? (0, _SourceMapUrls.decodeBase64String)(encoded) : decodeURIComponent(encoded), data);
    } catch (error) {
      error.sourceMapData = data;
      throw error;
    }

    return data;
  } // sources in different file


  var mapUrl = (0, _SourceMapUrls.resolveUrl)(codeUrl, url);
  return {
    sourceMappingURL: url,
    url: mapUrl,
    sourcesRelativeTo: mapUrl,
    map: null
  };
}

function getMapData(sourceMapURL, codeUrl, read) {
  let mapData;

  try {
    mapData = parseSourceMappingUrl(sourceMapURL, codeUrl);
  } catch (error) {
    _logger.logger.debug("Skipping current sourceMapURL.", error.message, "was thrown.");

    return null;
  } // if the source map is in a different file we need to read it


  if (mapData && !mapData.map) {
    try {
      mapData.map = (0, _SourceMapUrls.readSync)(read, mapData.url, mapData);
      mapData.map = (0, _SourceMapUrls.parseMapToJSON)(mapData.map, mapData);
    } catch (error) {
      _logger.logger.debug("Failed to read and parse the source map (" + mapData.url + "), skipping.", error.message, "was thrown.");

      return null;
    }
  }

  return mapData;
} // Returns a list of objects containing the source maps' data


function allSourceMaps(code, codeUrl, read) {
  const allSources = [];

  if (_config.default.LoggingConfiguration.ROOKOUT_SOURCEMAP_DEBUG) {
    _logger.logger.debug("Started parsing source maps for url: " + codeUrl);
  }

  let match;

  if (_InspectorDebug.InspectorDebug.validate_version(12)) {
    match = getAllUrls(code);
  } else {
    match = oldGetAllUrls(code);
  }

  if (match.length === 0) {
    if (_config.default.LoggingConfiguration.ROOKOUT_SOURCEMAP_DEBUG) {
      _logger.logger.debug("Skipping " + codeUrl + " found 0 source map urls.");
    }

    return allSources;
  }

  for (let sourceMap of match) {
    let mapData = getMapData(sourceMap, codeUrl, read);

    if (mapData) {
      allSources.push(mapData);
    }
  }

  if (allSources.length < match.length) {
    _logger.logger.debug("Could only parse", allSources.length + "/" + match.length, "source maps at", codeUrl);
  } else if (allSources.length === match.length) {
    _logger.logger.debug("Successfully parsed all (" + allSources.length + ") source maps at", codeUrl);
  } else {
    _logger.logger.debug("Parsed too many (" + allSources.length + "/" + match.length + ") source maps at", codeUrl);
  }

  return allSources;
}

module.exports = {
  allSourceMaps: allSourceMaps,
  getMapData: getMapData
};