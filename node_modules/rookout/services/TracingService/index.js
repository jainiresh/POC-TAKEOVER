"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TracingService = void 0;

var _IService = require("../IService");

var _OpenTelemetryProvider = require("./OpenTelemetryProvider");

var _DatadogProvider = require("./DatadogProvider");

class TracingService extends _IService.IService {
  constructor() {
    super();
    this.provider = undefined;
  }
  /**
   * Start the tracing service. Internally, this uses one of the following tracing providers, in the following order:
   * 1. OpenTelemetry
   * 2. Datadog
   */


  start() {
    const providers = [new _OpenTelemetryProvider.OpenTelemetryProvider(), new _DatadogProvider.DatadogProvider()];

    for (const provider of providers) {
      if (provider.patch() === true) {
        this.provider = provider;
        return;
      }
    }
  }
  /**
   * Closes the tracing service.
   */


  close() {
    // TODO: Add code that undoes our patching to the tracing provider interface
    this.provider = undefined;
  }
  /**
   * Checks if the tracing service is already set up and working
   * @returns {boolean} true if the service is on, false if it is off or not started yet
   */


  isTracingEnabled() {
    if (this.provider === undefined) {
      return false;
    }

    return this.provider.isTracingEnabled();
  }
  /**
   * Retrieves the current span from the tracing provider.
   * @returns {undefined|*} the current active span, or undefined if there is no current active span or the service
   * hasn't started yet
   */


  getCurrentSpan() {
    var _this$provider;

    return (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.getCurrentSpan();
  }
  /**
   * Returns a V8 breakpoint condition, used to evaluate the current span. This is useful if we can't get the context
   * of the current active span just by hooking functions or reading from somewhere correctly (e.g. we can't read
   * AsyncLocalStorage)
   * @returns {undefined|string} The condition, or undefined if no condition is needed for the current provider, or if
   * the service hasn't started yet
   */


  setDebuggerEvaluationCondition() {
    if (this.provider === undefined) {
      return;
    }

    return this.provider.setDebuggerEvaluationCondition();
  }
  /**
   * Get the name of the rookout label matching the current active provider
   * @returns {undefined|string} The name of the label, or undefined if the service hasn't started yet
   */


  getLabelName() {
    if (this.provider === undefined) {
      return undefined;
    }

    return this.provider.getLabelName();
  }

}

exports.TracingService = TracingService;