"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PinoProvider = void 0;

var _BasicProvider = require("./BasicProvider");

var _LogRecord = require("./LogRecord");

var _utils = require("../../utils");

var _logger = require("../../logger");

class PinoProvider extends _BasicProvider.BasicProvider {
  constructor(loggingService) {
    super(loggingService);
    this.module = _LogRecord.LogModules.PINO;
  }

  patch() {
    const pino = (0, _utils.conditionalRequire)('pino');
    const pinoSymbols = (0, _utils.conditionalRequire)('pino/lib/symbols');
    const pinoLevels = (0, _utils.conditionalRequire)('pino/lib/levels');
    const pinoPath = (0, _utils.conditionalResolve)('pino');

    if (!pino || !pinoSymbols || !pinoLevels || !pinoPath) {
      return false;
    }

    if (!pino.toString().split('\n')[0].includes('(...args)')) {
      _logger.logger.error("did not override Pino's logger because of unexpected args", {
        func: pino.toString()
      });

      return false;
    }

    const self = this;

    require.cache[pinoPath].exports = (...args) => {
      const logger = pino(...args);
      self.hookPinoLogger(logger);
      return logger;
    };

    return true;
  }

  hookPinoLogger(logger) {
    const pinoSymbols = (0, _utils.conditionalRequire)('pino/lib/symbols');
    const pinoLevels = (0, _utils.conditionalRequire)('pino/lib/levels');
    const self = this;
    const chindingsSymbol = pinoSymbols.chindingsSym;
    const setLevelSymbol = pinoSymbols.setLevelSym;
    self.hookPinoLoggingFunctions(logger, chindingsSymbol); // Hooking setLevel (used by the setter of the `level` attribute of the logger),
    // since it overrides the different logging functions every time

    const oldSetLevels = pinoLevels.setLevel;

    logger[setLevelSymbol] = levelName => {
      oldSetLevels.call(logger, levelName);
      self.hookPinoLoggingFunctions(logger, chindingsSymbol);
    }; // Hooking `child` since it creates a new logger out of the existing one


    const oldChild = logger.child;

    logger.child = (...args) => {
      const childLogger = oldChild.call(logger, ...args);
      self.hookPinoLogger(childLogger);
      return childLogger;
    };
  }

  hookPinoLoggingFunctions(logger, chindingsSymbol) {
    const levels = {
      trace: "TRACE",
      debug: "DEBUG",
      info: "INFO",
      warn: "WARN",
      error: "ERROR",
      fatal: "FATAL"
    };

    for (const level in levels) {
      if (!logger[level]) {
        continue;
      }

      logger[level] = this.generatePinoLogFunction(levels[level], logger, logger[level], chindingsSymbol);
    }
  }

  generatePinoLogFunction(levelName, logger, originalLogFunction, chindingsSymbol) {
    const self = this;
    return function (o, ...n) {
      const args = {
        firstArg: o,
        rest: n,
        chindings: logger[chindingsSymbol]
      };
      self.onNewLog({
        message: undefined,
        level: levelName,
        created: Date.now() / 1000,
        args: args
      });
      originalLogFunction.call(logger, o, ...n);
    };
  }

  unpatch() {}

}

exports.PinoProvider = PinoProvider;