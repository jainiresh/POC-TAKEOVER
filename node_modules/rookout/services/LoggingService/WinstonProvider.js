"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinstonProvider = void 0;

var _BasicProvider = require("./BasicProvider");

var _LogRecord = require("./LogRecord");

var _utils = require("../../utils");

var _logger = require("../../logger");

const rookoutTransportName = 'rookoutTransport';
const transportNameInUpperCase = rookoutTransportName.charAt(0).toUpperCase() + rookoutTransportName.slice(1);

class WinstonProvider extends _BasicProvider.BasicProvider {
  constructor(loggingService) {
    super(loggingService);
  }

  patch() {
    // If Winston isn't installed this will throw an exception which will be caught by TriggerServices which will
    // skip the service
    const winston = (0, _utils.conditionalRequire)('winston');
    const transport = (winston === null || winston === void 0 ? void 0 : winston.Transport) || (0, _utils.conditionalRequire)('winston-transport');

    if (!winston || !transport) {
      return false;
    }

    if (winston.version.startsWith("3.")) {
      this.module = _LogRecord.LogModules.WINSTON3;
      return this.startWinston3(winston);
    } else if (winston.version.startsWith("2.")) {
      this.module = _LogRecord.LogModules.WINSTON2;
      return this.startWinston2(winston);
    }

    return false; // todo: loggers created by winston.createLogger() before rookout init and weren't saved into a container. (winston 3.*)
    // example:
    //   const logger = winston.createLogger();
    //   rookout.start();
    //   logger.info('hello world');
    // todo: loggers created by new winston.Logger() before rookout init and weren't saved into a container. (winston 2.*)
    // example:
    //   const logger = new winston.Logger();
    //   rookout.start();
    //   logger.info('hello world');
    // todo: loggers created inside manual containers before rookout init.
    // example:
    //   const container = new winston.Container();
    //   container.add('logger-id', opts);
    //   rookout.start();
    //   const logger = conainer.get('logger-id');
    //   logger.info('hello world');
  }

  startWinston3(winston) {
    let hooked = false;
    hooked |= this.hookWinston3CreateLogger(winston);
    hooked |= this.hookWinston3Add(winston);
    hooked |= this.AddWinston3Transport(winston);
    hooked |= this.AddToWinston3DefaultLogger(winston);
    return hooked;
  }

  startWinston2(winston) {
    let hooked = false;
    hooked |= this.hookWinston2Configure(winston);
    hooked |= this.AddWinston2Transport(winston);
    hooked |= this.AddToWinston2DefaultLogger(winston);
    return hooked;
  }

  hookWinston3CreateLogger(winston) {
    // override winston.createLogger(). the logger creator for winston 3.*
    const originalCreateLogger = winston.createLogger;

    if (originalCreateLogger === undefined) {
      _logger.logger.info("Skipped winston.createdLogger (missing)");

      return false;
    }

    if (!originalCreateLogger.toString().split('\n')[0].includes("(opts = {})")) {
      _logger.logger.error("did not override winston.createLogger() because of unexpected args", {
        func: winston.createLogger.toString()
      });

      return false;
    }

    winston.createLogger = (opts = {}) => {
      opts.transports = this.addRookoutWinstonTransportToTransports(opts.transports, true);
      return originalCreateLogger(opts);
    };

    _logger.logger.info("Hooked winston.createLogger");

    return true;
  }

  hookWinston3Add(winston) {
    // override winston.loggers.add() for winston 3. winston 2.* doesn't need monkey patching for loggers.add()
    // because it uses the Logger constructor we have already patched.
    const originalAddLogger = winston.loggers.add;

    if (originalAddLogger.length !== 2) {
      _logger.logger.error("did not override winston.loggers.add() because of unexpected args", {
        func: winston.loggers.add.toString()
      });

      return false;
    }

    const callAddRookoutTransportToTransports = options => this.addRookoutWinstonTransportToTransports(options.transports, true);

    winston.loggers.add = function (id, options = {}) {
      options.transports = callAddRookoutTransportToTransports(options);
      return originalAddLogger.apply(this, [id, options]);
    };

    _logger.logger.info("Hooked winston.loggers.add()");

    return true;
  }

  AddWinston3Transport(winston) {
    var _winston$loggers;

    // add Rookout logging transport to existing loggers in the default container
    const loggers = winston === null || winston === void 0 ? void 0 : (_winston$loggers = winston.loggers) === null || _winston$loggers === void 0 ? void 0 : _winston$loggers.loggers;

    if (loggers === undefined) {
      return false;
    }

    const RookoutWinston3Transport = this.getRookoutWinston3TransportClass();

    if (!RookoutWinston3Transport) {
      return false;
    }

    loggers.forEach(loggerInstance => {
      loggerInstance.add(new RookoutWinston3Transport({}));
    });

    _logger.logger.info("added Rookout transport to winston 3.* default container loggers");

    return true;
  }

  AddToWinston3DefaultLogger(winston) {
    // add Rookout logging transport to winston default logger. `winston.info("log message")`
    const defaultLogger = winston.default;

    if (defaultLogger === undefined) {
      return false;
    }

    const RookoutWinston3Transport = this.getRookoutWinston3TransportClass();

    if (!RookoutWinston3Transport) {
      return false;
    }

    winston.add(new RookoutWinston3Transport({}));

    _logger.logger.info("added Rookout transport to winston 3.* default logger");

    return true;
  }

  hookWinston2Configure(winston) {
    // override the configure prototype which is called from the constructor, constructor is overrun by inheritence. this is winston 2.* specific
    const originalLoggerConfigure = winston.Logger.prototype.configure;

    if (originalLoggerConfigure === undefined) {
      _logger.logger.info("Skipped winston.Logger.prototype.configure (missing)");

      return false;
    }

    if (!originalLoggerConfigure.toString().split('\n')[0].includes("(options)")) {
      _logger.logger.error("did not override winston.Logger.prototype.configure() constructor because of unexpected args", {
        func: winston.Logger.prototype.configure.toString()
      });

      return false;
    }

    const callAddRookoutTransportToTransports = transports => this.addRookoutWinstonTransportToTransports(transports, false);

    winston.Logger.prototype.configure = function (options) {
      options.transports = callAddRookoutTransportToTransports(options.transports);
      return originalLoggerConfigure.apply(this, [options]);
    };

    _logger.logger.info("Hooked winston.Logger.prototype.configure");

    return true;
  }

  AddWinston2Transport(winston) {
    var _winston$loggers2;

    // add Rookout logging transport to existing loggers in the default container
    const loggers = winston === null || winston === void 0 ? void 0 : (_winston$loggers2 = winston.loggers) === null || _winston$loggers2 === void 0 ? void 0 : _winston$loggers2.loggers;

    if (loggers === undefined) {
      return false;
    }

    const RookoutWinston2Transport = this.getRookoutWinston2TransportClass();
    winston.transports[transportNameInUpperCase] = RookoutWinston2Transport;

    if (!RookoutWinston2Transport) {
      return false;
    }

    for (const [, loggerInstance] of Object.entries(loggers)) {
      loggerInstance.add(RookoutWinston2Transport, {});
    }

    _logger.logger.info("added Rookout transport to winston 2.* default container loggers");

    return true;
  }

  AddToWinston2DefaultLogger(winston) {
    // add Rookout logging transport to winston default logger. `winston.info("log message")`
    const defaultLogger = winston.default;

    if (defaultLogger === undefined) {
      return false;
    }

    const RookoutWinston2Transport = this.getRookoutWinston2TransportClass();

    if (!RookoutWinston2Transport) {
      return false;
    } // in winston 2.* it's required to add our transport to the list of valid transports


    winston.transports[transportNameInUpperCase] = RookoutWinston2Transport;
    winston.add(RookoutWinston2Transport, {});

    _logger.logger.info("added Rookout transport to winston 2.* default logger");

    return true;
  }

  addRookoutWinstonTransportToTransports(existingTransports, isWinston3) {
    const RookoutWinstonTransport = isWinston3 ? this.getRookoutWinston3TransportClass() : this.getRookoutWinston2TransportClass();

    if (!isWinston3) {
      // in winston 2.* it's required to add our transport to the list of valid transports
      const winston = (0, _utils.conditionalRequire)('winston');
      winston.transports[transportNameInUpperCase] = RookoutWinstonTransport;
    }

    if (!RookoutWinstonTransport) {
      return existingTransports;
    }

    const newTransport = new RookoutWinstonTransport({});

    if (Array.isArray(existingTransports)) {
      if (existingTransports.some(transport => transport instanceof RookoutWinstonTransport)) {
        return existingTransports;
      }

      return [newTransport, ...existingTransports];
    } else if (existingTransports) {
      if (existingTransports instanceof RookoutWinstonTransport) {
        return existingTransports;
      }

      return [newTransport, existingTransports];
    } else {
      return [newTransport];
    }
  }

  getRookoutWinston3TransportClass() {
    const winston = (0, _utils.conditionalRequire)('winston');
    const Transport = (0, _utils.conditionalRequire)('winston-transport');

    if (!winston || !Transport) {
      return null;
    }

    const onNewLog = info => this.onNewLog(info);

    return class RookoutWinston3Transport extends Transport {
      constructor(opts) {
        opts.level = 'debug';
        super(opts);
      }

      log(info, callback) {
        setImmediate(() => {
          this.emit('logged', info);
        });
        info.created = Date.now() / 1000;
        onNewLog(info);
        callback();
      }

    };
  }

  getRookoutWinston2TransportClass() {
    const winston = (0, _utils.conditionalRequire)('winston');
    const Transport = winston === null || winston === void 0 ? void 0 : winston.Transport;

    if (!Transport) {
      return null;
    }

    const onNewLog = info => this.onNewLog(info);

    return class RookoutWinston2Transport extends Transport {
      constructor(opts) {
        opts.name = rookoutTransportName;
        opts.level = 'debug';
        super(opts);
      }

      log(level, message, meta, callback) {
        setImmediate(() => {
          this.emit('logged', message);
        });
        const info = {
          message,
          level,
          meta,
          created: Date.now() / 1000
        };
        onNewLog(info);
        callback();
      }

    };
  }

  unpatch() {}

}

exports.WinstonProvider = WinstonProvider;