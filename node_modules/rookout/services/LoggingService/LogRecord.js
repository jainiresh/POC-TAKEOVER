"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LogRecord = exports.LogModules = exports.LOG_RECORD_MESSAGE_FIELD_NAME = exports.LOG_RECORD_LOG_FILEPATH_FIELD_NAME = exports.LOG_RECORD_LOG_CONTEXT_FIELD_NAME = exports.LOG_RECORD_LINENO_FIELD_NAME = exports.LOG_RECORD_LEVEL_NAME_FIELD_NAME = void 0;

var _utils = require("../../utils");

const _excluded = ["level", "message", "meta"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const path = require('path');

const util = (0, _utils.conditionalRequire)('util');
const pinoFormatter = (0, _utils.conditionalRequire)('quick-format-unescaped') || (util === null || util === void 0 ? void 0 : util.format);
const LogModules = Object.freeze({
  BASIC_PROVIDER: "BASIC_PROVIDER",
  CONSOLE: "CONSOLE",
  WINSTON2: "WINSTON2",
  WINSTON3: "WINSTON3",
  LOG4JS: "LOG4JS",
  PINO: "PINO"
});
exports.LogModules = LogModules;
const LOG_RECORD_MESSAGE_FIELD_NAME = "msg";
exports.LOG_RECORD_MESSAGE_FIELD_NAME = LOG_RECORD_MESSAGE_FIELD_NAME;
const LOG_RECORD_LEVEL_NAME_FIELD_NAME = "levelname";
exports.LOG_RECORD_LEVEL_NAME_FIELD_NAME = LOG_RECORD_LEVEL_NAME_FIELD_NAME;
const LOG_RECORD_LOG_CONTEXT_FIELD_NAME = "log_context";
exports.LOG_RECORD_LOG_CONTEXT_FIELD_NAME = LOG_RECORD_LOG_CONTEXT_FIELD_NAME;
const LOG_RECORD_LINENO_FIELD_NAME = "lineno";
exports.LOG_RECORD_LINENO_FIELD_NAME = LOG_RECORD_LINENO_FIELD_NAME;
const LOG_RECORD_LOG_FILEPATH_FIELD_NAME = "filename";
exports.LOG_RECORD_LOG_FILEPATH_FIELD_NAME = LOG_RECORD_LOG_FILEPATH_FIELD_NAME;

class LogRecord {
  constructor(record, module) {
    this.unparsedLevelName = record.level;
    this.levelname = null;
    this.unparsedMessage = record.message;
    this.msg = null;
    this.time = record.created;
    this.module = module;
    this.record = record;
    this.log_context = null;
    this.location = null;
    this.lineno = null;
    this.filename = null;
  }

  getLevelName() {
    this.formatLevelName();
    return this.levelname;
  }

  formatLevelName() {
    if (this.levelname === null) {
      this.levelname = this.unparsedLevelName.toUpperCase();
    }
  }

  getMessage() {
    if (this.msg === null) {
      this.formatMessage();
    }

    return this.msg;
  }

  getContext() {
    if (this.log_context === null) {
      this.setContext();
    }

    return this.log_context;
  }

  formatMessage() {
    if (this.msg !== null) {
      return;
    }

    switch (this.module) {
      case LogModules.CONSOLE:
        this.msg = this.getFormattedConsoleLogMessage(this.unparsedMessage);
        break;

      case LogModules.WINSTON2:
      case LogModules.WINSTON3:
        this.msg = this.getFormattedWinstonLogMessage(this.unparsedMessage);
        break;

      case LogModules.LOG4JS:
        this.msg = this.getFormattedLog4jsLogMessage(this.unparsedMessage);
        break;

      case LogModules.PINO:
        this.msg = this.getFormattedPinoLogMessage(this.unparsedMessage);
        break;

      default:
        break;
    }
  }

  safeJsonStringify(obj) {
    const getCircularReplacer = () => {
      const seen = new WeakSet();
      return (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return;
          }

          seen.add(value);
        }

        return value;
      };
    }; // Errors don't have any enumerable fields, so we need to create a copy object to JSON.stringify it


    if (obj instanceof Error) {
      let new_obj = {};
      Object.getOwnPropertyNames(obj).forEach(key => {
        new_obj[key] = obj[key];
      });
      obj = new_obj;
    }

    return JSON.stringify(obj, getCircularReplacer());
  }

  getFormattedConsoleLogMessage(message) {
    return message.map(obj => {
      if (typeof obj === "object") {
        const jsonObj = this.safeJsonStringify(obj);

        if (obj.constructor.name !== "Object") {
          return `${obj.constructor.name} ${jsonObj}`;
        }

        return jsonObj;
      }

      return obj;
    }).join(" ");
  }

  getFormattedWinstonLogMessage(message) {
    return message;
  }

  getFormattedLog4jsLogMessage(message) {
    return util ? util.format(...message) : message.toString();
  }

  getFormattedPinoLogMessage(message) {
    const firstArg = this.record.args.firstArg;
    const rest = this.record.args.rest;
    const secondArg = this.record.args.rest[0];

    if (pinoFormatter === undefined) {
      return firstArg.toString();
    } // There are several ways to log in Pino:
    //     1. The first argument is a string - then the message is a formatting message, with the rest arguments
    //        being interpolated into the message
    //     2. The first argument is an object, and the second argument is a string - then the second argument is
    //        just like the first argument in the previous case
    //     3. The first argument is an error (and no more arguments) - then the error message is used
    //     4. The first argument is an object with a `msg` property (and no more arguments) - then the `msg`
    //        property is used
    //     5. Else, return an empty string


    let formattedMessage = '';

    if (firstArg instanceof String || typeof firstArg === 'string') {
      formattedMessage = pinoFormatter(firstArg, rest);
    } else if (secondArg instanceof String || typeof secondArg === 'string') {
      formattedMessage = pinoFormatter(secondArg, rest.slice(1));
    } else if (firstArg instanceof Error) {
      // Note: there is a bug in pino, where even if the second argument *IS NOT* a string,
      // it is still being treated as such. So we need to support that as well
      formattedMessage = secondArg !== undefined ? secondArg.toString() : firstArg['message'];
    } else if (firstArg['msg'] !== undefined) {
      formattedMessage = firstArg['msg'];
    }

    return formattedMessage;
  }

  getLineno() {
    if (this.location === null) {
      this.setLogLocation();
    }

    return this.lineno;
  }

  getFilename() {
    if (this.location === null) {
      this.setLogLocation();
    }

    return this.filename;
  }

  getWinston3LogLocation() {
    const oldLimit = Error.stackTraceLimit;

    try {
      Error.stackTraceLimit = 50;
      const e = new Error();
      const stackTrace = e.stack.split('\n');

      for (let i = stackTrace.length - 2; i >= 0; i--) {
        // A stack trace element looks like this:
        //
        //     at DerivedLogger.log (/path/node_modules/winston/lib/winston/logger.js:216:12)
        //
        // We want to get the filename and line number
        const stackTraceElement = stackTrace[i];

        if (stackTraceElement.indexOf('at DerivedLogger') !== -1) {
          const callerStackTrace = stackTrace[i + 1];
          const location = callerStackTrace.match(/ \((.+)\)$/);

          if (location && location.length >= 2) {
            const uri = location[1];
            const uriParser = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            const parts = uriParser.exec(uri);

            if (parts) {
              return {
                lineno: parts[2],
                filename: path.basename(parts[1])
              };
            }
          }

          break;
        }
      }

      return {};
    } finally {
      Error.stackTraceLimit = oldLimit;
    }
  }

  getWinston2LogLocation() {
    const oldLimit = Error.stackTraceLimit;

    try {
      Error.stackTraceLimit = 35;
      const e = new Error();
      const stackTrace = e.stack.split('\n');

      for (let i = stackTrace.length - 2; i >= 0; i--) {
        // A stack trace element looks like this:
        //
        //     at Logger.log (/path/node_modules/winston/lib/winston/logger.js:246:9)
        //
        // We want to get the filename and line number
        const stackTraceElement = stackTrace[i];

        if (stackTraceElement.indexOf('/winston/lib/winston/logger.js') !== -1) {
          // In Winston2, the stack trace element we want depends on what function was called -
          // if it's `logger.log`, then it is the next one, and if it's `logger.info/error/etc`
          // we want the one after the next
          // In the second case, the next stack trace element looks like this:
          //
          //     at target.<computed> [as info] (/path/node_modules/winston/lib/winston/common.js:54:18)
          //
          const isLogFunction = stackTrace[i + 1].indexOf('<computed>') === -1;
          const callerStackTrace = isLogFunction ? stackTrace[i + 1] : stackTrace[i + 2];
          const location = callerStackTrace.match(/ \((.+)\)$/);

          if (location && location.length >= 2) {
            const uri = location[1];
            const uriParser = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            const parts = uriParser.exec(uri);

            if (parts) {
              return {
                lineno: parts[2],
                filename: path.basename(parts[1])
              };
            }
          }

          break;
        }
      }

      return {};
    } finally {
      Error.stackTraceLimit = oldLimit;
    }
  }

  setLogLocation() {
    if (this.location !== null) {
      return;
    }

    switch (this.module) {
      case LogModules.WINSTON3:
        this.location = this.getWinston3LogLocation();
        this.lineno = this.location.lineno;
        this.filename = this.location.filename;
        break;

      case LogModules.WINSTON2:
        this.location = this.getWinston2LogLocation();
        this.lineno = this.location.lineno;
        this.filename = this.location.filename;
        break;

      default:
        this.location = {};
        break;
    }
  }

  setWinston3Context() {
    const _this$record = this.record,
          {
      level,
      message,
      meta
    } = _this$record,
          others = _objectWithoutProperties(_this$record, _excluded);

    this.log_context = {};

    for (const key in meta) {
      this.log_context[key] = this.safeJsonStringify(meta[key]);
    }

    for (const key in others) {
      this.log_context[key] = this.safeJsonStringify(others[key]);
    }
  }

  setWinston2Context() {
    this.log_context = {};

    for (const key in (_this$record2 = this.record) === null || _this$record2 === void 0 ? void 0 : _this$record2.meta) {
      var _this$record2;

      this.log_context[key] = this.safeJsonStringify(this.record.meta[key]);
    }
  }

  setLog4jsContext() {
    // For log4js, we only support log context passed by calling `addContext`, and not by calling
    // `log4js.configure`. For more info between the difference between the two kinds,
    // see https://log4js-node.github.io/log4js-node/layouts.html, under the title "Tokens"
    this.log_context = {};

    for (const key in (_this$record3 = this.record) === null || _this$record3 === void 0 ? void 0 : _this$record3.log_context) {
      var _this$record3;

      this.log_context[key] = this.safeJsonStringify(this.record.log_context[key]);
    }
  }

  setPinoContext() {
    this.log_context = {};
    const firstArg = this.record.args.firstArg;

    if (firstArg instanceof Error) {
      this.log_context['err'] = this.safeJsonStringify(firstArg);
    } else if (!(firstArg instanceof String || typeof firstArg === 'string')) {
      for (const key in firstArg) {
        this.log_context[key] = this.safeJsonStringify(firstArg[key]);
      }
    } // Add chindings (child bindings)
    // Chindings are saved as the string representation, like so:
    //
    //      ',"pid":111,"hostname":"myhostname","child":"field"'
    //
    // so we need to convert it to proper js object first


    const chindings = this.record.args.chindings;
    const parsedChindings = JSON.parse('{' + chindings.slice(1) + '}');

    for (const key in parsedChindings) {
      this.log_context[key] = this.safeJsonStringify(parsedChindings[key]);
    }
  }

  setContext() {
    if (this.log_context !== null) {
      return;
    }

    switch (this.module) {
      case LogModules.WINSTON3:
        this.setWinston3Context();
        break;

      case LogModules.WINSTON2:
        this.setWinston2Context();
        break;

      case LogModules.LOG4JS:
        this.setLog4jsContext();
        break;

      case LogModules.PINO:
        this.setPinoContext();
        break;

      default:
        break;
    }
  }

}

exports.LogRecord = LogRecord;