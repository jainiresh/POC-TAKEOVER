"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("../logger");

var _SourceMapsHelper = require("./SourceMapsHelper");

var _SourceFile = require("./SourceFile");

var _traceMapping = require("@jridgewell/trace-mapping");

var _sourceMapUtil = require("./source-map-util");

var _utils = require("../utils");

var _exceptions = require("../exceptions");

var _RookError = _interopRequireDefault(require("../processor/RookError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fs = require('fs');

const path = require('path');

const ALL_LINE_ENDINGS = /(?:\r\n|\r|\n)/g;

class ScriptWrapper {
  constructor(id, filename, source, sourceMapURL) {
    this.id = id;
    this.sourceFiles = [];
    this.filename = filename;
    this.normalizedFilename = (0, _utils.canonizeFileName)(filename);
    this.baseName = path.basename(this.filename);
    this.external = filename.includes('/node_modules/');
    this.fileHash = null;
    this.linesCrc32s = null;
    this.wasLoaded = false;
    this.hasSourceMaps = false;
    this.mapConsumers = [];

    if (sourceMapURL) {
      this.loadSingleMap(sourceMapURL);
    } else {
      this.loadMaps(source);
    }

    this.localScriptTranspiled = false;

    if (!this.hasSourceMaps && !this.external) {
      this.localScriptTranspiled = this.hasTranspilerHeader(source);
    }

    this.typescriptMismatch = false;

    if (this.sourceFiles.length > 0) {
      this.typescriptMismatch = this.hasTypescriptMismatch();
    } // Within the same source file (which is always evaluated atomically) place shorter paths before longer paths


    this.sourceFiles.sort((file1, file2) => file1.priority - file2.priority);
  }

  getFileHash() {
    this.loadSourceFile();
    return this.fileHash;
  }

  getLinesCrc32s() {
    this.loadSourceFile();
    return this.linesCrc32s;
  }

  loadSourceFile() {
    if (this.wasLoaded) {
      return;
    }

    try {
      let source = this.getRawFileContents(this.filename);

      if (source === null) {
        this.fileHash = null;
        this.linesCrc32s = null;
      } else {
        source = source.replace(ALL_LINE_ENDINGS, "\n");
        this.fileHash = (0, _utils.sha256)(source);
        this.linesCrc32s = source.split("\n").map(line => (0, _utils.crc32)(line));
      }
    } catch (e) {
      _logger.logger.debug("Error loading file and calculating hashes ", this.rawPath, e.message);
    }

    this.wasLoaded = true;
  }

  hasTypescriptMismatch() {
    if (this.external) {
      return false;
    }

    try {
      for (const sourceFile of this.sourceFiles) {
        if (!sourceFile.baseName.endsWith('.ts')) {
          continue;
        }

        for (let i = 0; i < sourceFile.mapConsumer.sources.length; i++) {
          if (sourceFile.mapConsumer.sourcesContent[i] === null) {
            continue;
          }

          if (sourceFile.mapConsumer.sources[i].endsWith('.ts') && this.hasTranspilerHeader(sourceFile.mapConsumer.sourcesContent[i])) {
            return true;
          }
        }
      }
    } catch (_unused) {}

    return false;
  }

  hasTranspilerHeader(source) {
    // General uglifier
    // NOTE: The first string is *2* spaces, not a single one
    const nonUglyStrings = ["  ", "\t", "//"];
    let containsNonUglyString = false;
    const firstBytes = source.slice(0, 1000);

    for (const nonUglyString of nonUglyStrings) {
      if (firstBytes.includes(nonUglyString)) {
        containsNonUglyString = true;
        break;
      }
    } // We check that the script isn't short enough, because some JS sources
    // (like wasm) have an empty source. Other sources (like evalmachine) are
    // just a single word (`this`, or something related to the JS engine), so check
    // that there is at least one space or semicolon, to indicate proper JS code,
    // and make sure we aren't working on a script that isn't too short (since some of
    // our observations rely on a script long enough)


    let isUglified = !containsNonUglyString;
    isUglified &= firstBytes.length === 1000;
    isUglified &= firstBytes.includes(';') || firstBytes.includes(' ');
    isUglified &= firstBytes.split(/\r\n|\r|\n/).length <= 10;

    if (isUglified) {
      return true;
    } // Webpack header


    const webpack_var = "var __webpack_modules__";

    if (firstBytes.includes(webpack_var)) {
      return true;
    } // Babel header - Get the first 10 lines, and see if exports is being defined on Object


    const babel_header = "Object.defineProperty(exports, \"__esModule\", {";
    const first_lines = source.split('\n', 10).join('\n');

    if (first_lines.includes(babel_header)) {
      return true;
    } // Default - not transpiled


    return false;
  }

  createTraceMapAndSourceFile(mapData) {
    const mapConsumer = new _traceMapping.TraceMap(mapData.map);
    this.mapConsumers.push(mapConsumer);

    for (let sourceFilePath of mapData.map.sources) {
      const sourceFile = new _SourceFile.SourceFile(this.filename, sourceFilePath, mapConsumer);
      this.sourceFiles.push(sourceFile);
    }
  }

  loadSingleMap(sourceMapURL) {
    let mapData;

    try {
      mapData = (0, _SourceMapsHelper.getMapData)(sourceMapURL, this.filename, fs.readFileSync);
    } catch (e) {
      _logger.logger.debug("Unable to parse sourceMapURL", sourceMapURL, e.message);
    }

    this.createTraceMapAndSourceFile(mapData);
    this.hasSourceMaps = true;
  }

  loadMaps(source) {
    if (!this.filename || !source) {
      return;
    }

    let mapDatas = [];

    try {
      mapDatas = (0, _SourceMapsHelper.allSourceMaps)(source, this.filename, fs.readFileSync);
    } catch (e) {
      _logger.logger.debug("Unable to find source map", this.filename, e.message);
    }

    if (mapDatas.length > 1) {
      _logger.logger.debug(this.filename, " has ", mapDatas.length, " sourceMappingUrls");
    }

    if (mapDatas.length === 0) {
      return;
    }

    for (let mapData of mapDatas) {
      this.createTraceMapAndSourceFile(mapData);
    }

    this.hasSourceMaps = true;
  }

  getMatchInfo(notification) {
    if (this.external && !notification.includeExternals) {
      return null;
    }

    let fileHash = null;
    let linesCrc32s = null;
    let error = null;
    let updatedLineNumber = null;
    let generatedPosition = null;
    let lineno = null;
    let column = null;

    for (let sourceFile of this.sourceFiles) {
      if (this.arePathsConverging(sourceFile.normalizedPath, notification.filename)) {
        fileHash = sourceFile.getFileHash();
        linesCrc32s = sourceFile.getLinesCrc32s();

        try {
          if (fileHash === null || linesCrc32s === null) {
            notification.userWarnings.sendWarning(new _RookError.default(new _exceptions.RookSourceMissing(notification.filename)));
            updatedLineNumber = notification.lineno;
          } else {
            updatedLineNumber = this.getUpdateLineNumber(notification, fileHash, linesCrc32s);
          }

          generatedPosition = this.getGeneratedPosition((0, _sourceMapUtil.normalize)(sourceFile.rawPath), updatedLineNumber, notification.column);
          lineno = generatedPosition.line;
          column = generatedPosition.column;
        } catch (e) {
          // Those exceptions will be handled in LocationFileLine, should be handled here
          lineno = null;
          error = e;
        }

        return {
          script: this,
          lineno: lineno,
          column: column,
          error: error
        };
      }
    }

    if (this.arePathsConverging(this.normalizedFilename, notification.filename)) {
      try {
        updatedLineNumber = this.getUpdateLineNumber(notification, this.getFileHash(), this.getLinesCrc32s());
      } catch (e) {
        error = e;
      }

      return {
        script: this,
        lineno: updatedLineNumber,
        column: notification.column,
        error: error
      };
    }

    return null;
  }

  getMatchedFilename(FilenameBase, fileHash) {
    try {
      if (this.sourceFiles === null || this.sourceFiles === undefined) {
        return null;
      }

      for (const sourceFile of this.sourceFiles) {
        if (FilenameBase === sourceFile.baseName && sourceFile.getFileHash() === fileHash) {
          return sourceFile.normalizedPath;
        }
      }

      if (FilenameBase === this.baseName && this.getFileHash() === fileHash) {
        return this.filename;
      }

      return null;
    } catch (e) {
      return null;
    }
  }

  arePathsConverging(path1, path2) {
    // Find longest match
    let i = path1.length - 1;
    let j = path2.length - 1;

    while (i >= 0 && j >= 0 && path1[i] === path2[j]) {
      --i;
      --j;
    } // Check that at least one of the strings has ended and the other is at a directory boundary


    return i === -1 && path2[j] === path.sep || j === -1 && path1[i] === path.sep || i === -1 && j === -1;
  }

  getUpdateLineNumber(notification, fileHash, linesCrc32s) {
    if (null != notification.lineCrc32 && null != notification.lineUnique) {
      return this.updateLineUsingCrc(notification, fileHash, linesCrc32s);
    }

    if (null != fileHash && null != notification.fileHash) {
      this.testFileHash(notification, fileHash);
      return notification.lineno;
    }

    return notification.lineno;
  }

  updateLineUsingCrc(notification, fileHash, linesCrc32s) {
    // If the line has not changed, we are good - return
    let lineCrc32;

    if (linesCrc32s.length >= notification.lineno) {
      lineCrc32 = linesCrc32s[notification.lineno - 1];
    }

    if (lineCrc32 === notification.lineCrc32) {
      return notification.lineno;
    } // If the line was unique in the original file, let's try to find it in this file


    if (notification.lineUnique === true) {
      // If the line was unique in the original file and is still original here - send a warning and return
      const firstIndex = linesCrc32s.indexOf(notification.lineCrc32);
      const lastIndex = linesCrc32s.lastIndexOf(notification.lineCrc32);

      if (firstIndex !== -1 && firstIndex === lastIndex) {
        const updatedLine = firstIndex + 1;
        notification.userWarnings.sendWarning(new _RookError.default(new _exceptions.RookLineMoved(notification.filename, notification.lineno, updatedLine)));
        return updatedLine;
      }
    } // We failed to get a good match - throw an error


    throw new _exceptions.RookCrcMismatchException(notification.filename, notification.lineCrc32, lineCrc32);
  }

  testFileHash(notification, fileHash) {
    if (fileHash !== notification.fileHash) {
      throw new _exceptions.RookHashMismatchException(notification.filename, notification.fileHash, fileHash);
    }
  }

  getGeneratedPosition(filename, line, column) {
    let position = null;

    for (let mapConsumer of this.mapConsumers) {
      position = (0, _traceMapping.generatedPositionFor)(mapConsumer, {
        source: filename,
        line: line,
        column: column,
        bias: _traceMapping.LEAST_UPPER_BOUND
      }); // generatedPositionFor might return zeroed position instance upon failure and not null

      if (position !== null && position.line !== null) {
        if (null === position.column) {
          _logger.logger.warn("Got NULL column from source-map!");
        }

        return position;
      }
    }

    throw new _exceptions.RookResolveSourceFailed(this.filename);
  }

  getOriginalPosition(line, column) {
    let position = null;

    for (let mapConsumer of this.mapConsumers) {
      position = (0, _traceMapping.originalPositionFor)(mapConsumer, {
        line: line,
        column: column
      });

      if (position !== null && position.line !== null) {
        return position;
      }
    }

    _logger.logger.warn("Didn't find any original position for line: ", line, " column: ", column);

    return position;
  }

  getRawFileContents(filename) {
    try {
      return fs.readFileSync(filename, 'utf8');
    } catch (e) {
      throw new _exceptions.RookSourceError(filename, e);
    }
  }

}

exports.default = ScriptWrapper;