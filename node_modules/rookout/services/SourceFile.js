"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SourceFile = void 0;

var _logger = require("../logger");

var _utils = require("../utils");

var _traceMapping = require("@jridgewell/trace-mapping");

var _exceptions = require("../exceptions");

const fs = require('fs');

const path = require('path');

// Identify folder separators (ignoring the current folder one) based on the platform path separator
const FOLDERS = path.sep == '/' ? /[^\.]\/|\.\.\//g : /[^\.]\\|\.\.\\/g;
const ALL_LINE_ENDINGS = /(?:\r\n|\r|\n)/g;

class SourceFile {
  constructor(scriptFile, rawPath, mapConsumer) {
    var _this$normalizedPath$;

    this.scriptFile = scriptFile;
    this.normalizedPath = (0, _utils.canonizeFileName)(rawPath);
    this.baseName = path.basename(this.normalizedPath);
    this.priority = ((_this$normalizedPath$ = this.normalizedPath.match(FOLDERS)) === null || _this$normalizedPath$ === void 0 ? void 0 : _this$normalizedPath$.length) || 0;
    this.rawPath = rawPath;
    this.fileHash = null;
    this.linesCrc32s = null;
    this.mapConsumer = mapConsumer;
    this.wasLoaded = false;
  }

  loadRawFile() {
    // If we are dealing with a transpiled file, we prefer getting the source from disk
    // Otherwise, we have to stick with the source map, even if it's of lower accuracy
    const sourceFilePath = path.join(path.dirname(this.scriptFile), this.normalizedPath);
    const adjacentSourceFile = path.join(path.dirname(this.scriptFile), this.baseName);

    if (fs.existsSync(sourceFilePath)) {
      return this.getRawFileContents(sourceFilePath);
    } else if (adjacentSourceFile !== this.scriptFile && fs.existsSync(adjacentSourceFile)) {
      return this.getRawFileContents(adjacentSourceFile);
    }

    return (0, _traceMapping.sourceContentFor)(this.mapConsumer, this.rawPath, true);
  }

  loadSourceFile() {
    if (this.wasLoaded) {
      return;
    }

    try {
      let source = this.loadRawFile();

      if (source === null) {
        this.fileHash = null;
        this.linesCrc32s = null;
      } else {
        source = source.replace(ALL_LINE_ENDINGS, "\n");
        this.fileHash = (0, _utils.sha256)(source);
        this.linesCrc32s = source.split("\n").map(line => (0, _utils.crc32)(line));
      }
    } catch (e) {
      _logger.logger.debug("Error loading file and calculating hashes ", this.rawPath, e.message);
    }

    this.wasLoaded = true;
  }

  getFileHash() {
    this.loadSourceFile();
    return this.fileHash;
  }

  getLinesCrc32s() {
    this.loadSourceFile();
    return this.linesCrc32s;
  }

  getRawFileContents(filename) {
    try {
      return fs.readFileSync(filename, 'utf8');
    } catch (e) {
      throw new _exceptions.RookSourceError(this.scriptFile, e);
    }
  }

}

exports.SourceFile = SourceFile;