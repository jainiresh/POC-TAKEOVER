'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _exceptions = require("../exceptions");

var _Aug = require("./Aug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const utils = require("../utils");

const config = require('../config');

class RateLimiter {
  constructor(quota, window_size) {
    this.quota = quota;
    this.window_size = window_size;
    this.windows = new Map();
  }

  calculateWindowKey(time) {
    return Math.floor(time / this.window_size) * this.window_size;
  }

  beforeRun(now) {
    if (this.window_size === undefined) {
      return {
        limitStatus: _Aug.augStatus.Active,
        error: null
      };
    }

    this.cleanup(now);
    let current_window_key = this.calculateWindowKey(now);
    let prev_window_key = current_window_key - this.window_size;
    let current_window_usage = this.windows.get(current_window_key);

    if (current_window_usage === undefined) {
      current_window_usage = 0;
      this.windows.set(current_window_key, current_window_usage);
    }

    let previous_window_usage = this.windows.get(prev_window_key);

    if (previous_window_usage === undefined) {
      if (current_window_usage > this.quota) {
        return {
          limitStatus: _Aug.augStatus.Warning,
          error: new _RookError.default((0, _exceptions.RookRuleRateLimited)())
        };
      }
    } else {
      let prev_weight = 1 - (now - current_window_key) / this.window_size;
      let weighted_usage = previous_window_usage * prev_weight + current_window_usage;

      if (weighted_usage > this.quota) {
        return {
          limitStatus: _Aug.augStatus.Warning,
          error: new _RookError.default((0, _exceptions.RookRuleRateLimited)())
        };
      }
    }

    return {
      limitStatus: _Aug.augStatus.Active,
      error: null
    };
  }

  afterRun(startTime, minVal) {
    if (this.window_size === undefined) {
      return;
    }

    let duration = utils.getTimeInNanoseconds() - startTime;
    let key = this.calculateWindowKey(startTime); // always at least 1ms

    duration = Math.max(minVal, duration);
    this.windows.set(key, this.windows.get(key) + duration);
  }

  cleanup(now) {
    if (this.windows.size > 10) {
      for (let [key] of this.windows) {
        if (key < now - this.window_size * 5) {
          this.windows.delete(key);
        }
      }
    }
  }

}

exports.default = RateLimiter;