"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.augStatus = void 0;

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _exceptions = require("../exceptions");

var _logger = require("../logger");

var _UserWarnings = _interopRequireDefault(require("../UserWarnings"));

var _ContainerNamespace = _interopRequireDefault(require("../processor/namespaces/ContainerNamespace"));

var _JSUtilsNamespace = require("../processor/namespaces/JSUtilsNamespace");

var _NoopNamespace = require("../processor/namespaces/NoopNamespace");

var _ProcessStateNamespace = require("../processor/namespaces/ProcessStateNamespace");

var _TraceNamespace = require("../processor/namespaces/TraceNamespace");

var _uuid = require("uuid");

var _config = _interopRequireDefault(require("../config"));

var _LimitManager = _interopRequireDefault(require("./LimitManager"));

var _utils = require("../utils");

var _InspectorStackNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorStackNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const utils = require("../utils");

const augStatus = {
  Deleted: "Deleted",
  Warning: "Warning",
  Error: "Error",
  Active: "Active",
  Pending: "Pending",
  Unknown: "Unknown"
};
exports.augStatus = augStatus;

class Aug {
  constructor(augId, location, action, condition, output, triggerServices, maxAugTime, limitManager, timeout = 2500, frameNum = 0) {
    this.triggerServices = triggerServices;
    this.augId = augId;
    this.location = location;
    this.action = action;
    this.output = output;
    this.status = null;
    this.maxAugTime = maxAugTime;
    this.enabled = true;
    this.condition = condition;
    this._warningCache = new Map();
    this._logCache = new Map();
    this.limitManager = limitManager;
    this.executed = false;
    this.timeout = timeout;
    this.userWarnings = new _UserWarnings.default(this);

    if (this.limitManager == null) {
      this.limitManager = new _LimitManager.default([]);
    }

    this.frameNum = frameNum;
  }

  addAug() {
    try {
      this.location.addAug(this.triggerServices, this);
    } catch (e) {
      const message = "Exception when adding aug";

      _logger.logger.exception(message, e);

      this.setError(new _RookError.default(e, message));
    }
  }

  removeAugTemporarilyAndReapplyAfterDuration(duration) {
    _logger.logger.info("Temporarily removing aug %s for %sms", this.augId, duration);

    this.triggerServices.removeAugTemporarily(this.augId, duration);
    this.enabled = false;
    let timeout = setTimeout(() => {
      this.enabled = true;
    }, duration);
    (0, _utils.nodeUnref)(timeout);
  }

  sendFullQueueWarningAndRemoveAugTemporarily() {
    this.output.sendOutputQueueFullWarning(this.augId);
    this.removeAugTemporarilyAndReapplyAfterDuration(this.timeout);
  }

  handleExecuteStatus(status) {
    if (status.limitStatus === this.status) {
      return;
    }

    if (status.limitStatus === augStatus.Warning) {
      this.removeAugTemporarilyAndReapplyAfterDuration(this.timeout);

      if (status.error != null) {
        this.sendWarning(status.error);
      }

      return;
    }

    _logger.logger.debug("handleExecuteStatus does not currently implement non-Warning augStatus");
  }

  executeInner(stack, extracted, msgId) {
    var _this$triggerServices;

    const tracingService = (_this$triggerServices = this.triggerServices) === null || _this$triggerServices === void 0 ? void 0 : _this$triggerServices.getService('TracingService');
    let traceNamespace = _NoopNamespace.NoopNamespaceInstance;

    if (tracingService !== null && tracingService !== void 0 && tracingService.isTracingEnabled()) {
      const span = tracingService.getCurrentSpan();

      if (span !== undefined) {
        traceNamespace = new _TraceNamespace.TraceNamespace(span, tracingService.provider.name);
      }
    }

    const skippedFramesStack = stack ? new _InspectorStackNamespace.default(stack.inspector, stack.callFrames.slice(this.frameNum)) : stack;
    let namespace = new _ContainerNamespace.default({
      'frame': stack ? stack.readKey(this.frameNum) : _NoopNamespace.NoopNamespaceInstance,
      'stack': skippedFramesStack || _NoopNamespace.NoopNamespaceInstance,
      'utils': _JSUtilsNamespace.JSUtilsNamespaceInstance,
      'trace': traceNamespace,
      'state': _ProcessStateNamespace.ProcessStateNamespaceInstance,
      'extracted': extracted
    });

    if (this.condition !== undefined) {
      if (!this.condition.evaluate(namespace)) {
        return;
      }
    }

    namespace.writeAttribute('store', new _ContainerNamespace.default({}));

    try {
      this.action.execute(this.augId, msgId, namespace, this.output, this.userWarnings);
    } catch (e) {
      if (e instanceof _exceptions.RookOutputQueueFull) {
        _logger.logger.debug("Original RookOutputQueueFull is %s", e.toString());

        this.sendFullQueueWarningAndRemoveAugTemporarily();
      } else {
        throw e;
      }
    }
  }

  execute(stack, extracted) {
    if (!this.enabled) {
      return;
    }

    if (this.output.areUserMessagesFull()) {
      this.sendFullQueueWarningAndRemoveAugTemporarily();
      return;
    }

    const startTime = utils.getTimeInNanoseconds();
    const shouldSkipLimiters = !this.executed && this.condition === undefined;
    let status = this.limitManager.tryWithLimits(startTime, shouldSkipLimiters, () => {
      try {
        const msgId = (0, _uuid.v4)().replace(/\-/g, "");

        if (this.executed) {
          _logger.logger.debug("Executing aug-\t%s (msg ID %s)", this.augId, msgId);
        } else {
          var _this$constructor;

          _logger.logger.info("Executing aug for the first time of type %s - %s", (_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name, this.augId);

          this.executed = true;
        }

        this.executeInner(stack, extracted, msgId);
        let duration = utils.getTimeInNanoseconds() - startTime;

        if (this.maxAugTime && this.maxAugTime > 0 && duration > this.maxAugTime) {
          this.enabled = false;
          this.triggerServices.removeAugfromInspector(this.augId);
          throw new _exceptions.RookRuleMaxExecutionTimeReached();
        }
      } catch (e) {
        const message = "Exception while processing Aug";
        let rookError = new _RookError.default(e, message);

        if (!this.shouldSilenceLog(rookError, this._logCache)) {
          _logger.logger.exception(message, e);
        }

        this.setError(rookError);
      }
    });
    this.handleExecuteStatus(status);
  }

  setActive() {
    this.sendRuleStatus(augStatus.Active);
  }

  setPending() {
    this.sendRuleStatus(augStatus.Pending);
  }

  setRemoved() {
    this.sendRuleStatus(augStatus.Deleted);
  }

  setError(error) {
    this.sendRuleStatus(augStatus.Error, error);
  }

  setUnknown(error) {
    this.sendRuleStatus(augStatus.Unknown, error);
  }

  sendWarning(error) {
    if (this.shouldSilenceLog(error, this._warningCache)) {
      return;
    }

    _logger.logger.warn(error.message);

    this.output.sendWarning(this.augId, error);
  }

  sendRuleStatus(status, error = null) {
    if (this.status === status) {
      return;
    }

    _logger.logger.info("Updating rule status for %s to %s", this.augId, status);

    this.status = status;
    this.output.sendRuleStatus(this.augId, status, error);
  }

  shouldSilenceLog(error, logCache) {
    if (logCache.has(error.message) || logCache.size >= 10) {
      return true;
    }

    logCache.set(error.message, true);
    return false;
  }

}

exports.default = Aug;