"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Aug = _interopRequireWildcard(require("./Aug"));

var _ActionRunProcessor = _interopRequireDefault(require("./actions/ActionRunProcessor"));

var _LocationFileLine = _interopRequireDefault(require("./locations/LocationFileLine"));

var _ProcessorFactory = _interopRequireDefault(require("../processor/ProcessorFactory"));

var _Condition = _interopRequireDefault(require("./conditions/Condition"));

var _exceptions = require("../exceptions");

var _LocationLogHandler = _interopRequireDefault(require("./locations/LocationLogHandler"));

var _LimitManager = _interopRequireDefault(require("./LimitManager"));

var _logger = require("../logger");

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _RateLimiter = _interopRequireDefault(require("./RateLimiter"));

var _LocationAssertTracking = _interopRequireDefault(require("./locations/LocationAssertTracking"));

var _AssertAug = require("./AssertAug");

var _LocationAnchorLines = _interopRequireDefault(require("./locations/LocationAnchorLines"));

var _AnchorLinesAug = require("./AnchorLinesAug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const config = require('../config');

const utils = require('../utils');

class AugFactory {
  constructor(output) {
    this.output = output;
    this.processorFactory = new _ProcessorFactory.default();
    this.globalRateLimiter = null;
    this.curAugTimeout = 2500;
  }

  getAug(configuration, triggerServices) {
    const augId = configuration["id"];

    if (!(typeof augId === 'string' || augId instanceof String)) {
      throw new _exceptions.RookAugInvalidKey('id', configuration);
    }

    const jsonLocation = configuration["location"];

    if (null == jsonLocation) {
      throw new _exceptions.RookAugInvalidKey('location', configuration);
    }

    const location = this.getLocation(jsonLocation);
    const jsonAction = configuration["action"];

    if (null == jsonAction) {
      throw new _exceptions.RookAugInvalidKey('action', configuration);
    }

    const action = new _ActionRunProcessor.default(jsonAction, this.processorFactory);
    let condition;
    const conditionConfiguration = configuration['conditional'];

    if (null != conditionConfiguration) {
      condition = new _Condition.default(conditionConfiguration);
    }

    let maxAugTime = configuration.maxAugTime === 0 ? 0 : configuration.maxAugTime || config.InstrumentationConfig.MAX_AUG_TIME_MS;
    maxAugTime = utils.MSToNS(maxAugTime);
    let limitsManager = this.createLimitsManager(configuration, location);

    if (jsonLocation.name === "assert_tracking") {
      return new _AssertAug.AssertAug(augId, location, action, condition, this.output, triggerServices, maxAugTime, limitsManager, this.curAugTimeout);
    } else if (jsonLocation.name === "anchor_lines") {
      return new _AnchorLinesAug.AnchorLinesAug(augId, location, action, condition, this.output, triggerServices, maxAugTime, limitsManager, this.curAugTimeout);
    }

    return new _Aug.default(augId, location, action, condition, this.output, triggerServices, maxAugTime, limitsManager, this.curAugTimeout);
  }

  createLimitsManager(configuration, location) {
    let limiters = [];

    if (this.getGlobalRateLimiter(configuration["id"]) != null) {
      limiters.push(this.getGlobalRateLimiter());
    } else {
      let rateLimiter = this.createRateLimiter(configuration['rateLimit'], 500, 5000);

      if (rateLimiter != null) {
        limiters.push(rateLimiter);
      }
    }

    return new _LimitManager.default(limiters, location.minTime);
  }

  getGlobalRateLimiter(augId = null) {
    if (this.globalRateLimiter == null && config.RateLimitConfiguration.GLOBAL_RATE_LIMIT !== "") {
      try {
        this.globalRateLimiter = this.createRateLimiter(config.RateLimitConfiguration.GLOBAL_RATE_LIMIT, 0, 0);

        if (this.globalRateLimiter == null) {
          throw new _exceptions.RookInvalidRateLimitConfiguration(config.RateLimitConfiguration.GLOBAL_RATE_LIMIT);
        }
      } catch (e) {
        if (e instanceof _exceptions.RookInvalidRateLimitConfiguration) {
          _logger.logger.debug(`Failed to create global rate limiter: ${e.message}`);

          if (augId != null) {
            this.output.sendRuleStatus(augId, _Aug.augStatus.Warning, new _RookError.default(e));
          }

          return null;
        } else {
          throw e;
        }
      }

      _logger.logger.debug(`Using global rate limiter with configuration: ${config.RateLimitConfiguration.GLOBAL_RATE_LIMIT}`);

      config.RateLimitConfiguration.USING_GLOBAL_RATE_LIMITER = true;
    }

    return this.globalRateLimiter;
  }

  createRateLimiter(limitsSpec, defaultQuota, defaultWindowSize) {
    let quota = utils.MSToNS(defaultQuota);
    let windowSize = utils.MSToNS(defaultWindowSize);

    if (limitsSpec !== undefined && limitsSpec.includes('/')) {
      let limitMatches = limitsSpec.split('/');

      if (limitMatches.length === 2) {
        quota = utils.MSToNS(limitMatches[0]) || quota;
        windowSize = utils.MSToNS(limitMatches[1]) || windowSize;
      }
    }

    if (quota === 0) {
      return null;
    }

    if (quota >= windowSize) {
      throw new _exceptions.RookInvalidRateLimitConfiguration(limitsSpec);
    }

    this.curAugTimeout = utils.NanosecToMillisec(windowSize) / 2; // We divide by 2 because the Node inspector has a significant overhead we can't measure during execution.

    return new _RateLimiter.default(quota, windowSize);
  }

  getLocation(jsonLocation) {
    switch (jsonLocation.name) {
      case "file_line":
        return new _LocationFileLine.default(jsonLocation, this.processorFactory);

      case "assert_tracking":
        return new _LocationAssertTracking.default(jsonLocation, this.processorFactory);

      case "anchor_lines":
        return new _LocationAnchorLines.default(jsonLocation, this.processorFactory);

      case "log_handler":
        return new _LocationLogHandler.default(jsonLocation, this.processorFactory);

      default:
        throw new _exceptions.RookUnsupportedLocation(jsonLocation.name);
    }
  }

}

exports.default = AugFactory;