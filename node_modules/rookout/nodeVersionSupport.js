"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVersionBiggerOrEqual = isVersionBiggerOrEqual;
exports.isVersionDeprecated = isVersionDeprecated;
exports.isVersionNonLTS = isVersionNonLTS;
exports.isVersionSupported = isVersionSupported;
exports.updateVersionSupport = updateVersionSupport;

var _logger = require("./logger");

const process = require('process');

const config = require('./config');

const hardcodedSupportedVersions = ["8.0.0-8.9.0", "8.9.2-12.22.12", "14.0.0-14.21.3", "16.0.0-16.20.2", "18.0.0-18.18.2", "20.0.0-20.9.0"];

function parseVersion(versionString) {
  const version = versionString.split('.');

  if (version.length < 3) {
    return undefined;
  }

  return version.map(x => parseInt(x));
}

function isVersionBiggerOrEqual(lhs, rhs) {
  return lhs[0] > rhs[0] || lhs[0] === rhs[0] && (lhs[1] > rhs[1] || lhs[1] === rhs[1] && lhs[2] >= rhs[2]);
}

function isInVersionRange(versionRange, ourVersion) {
  // The expected format is one of the following forms:
  // 1. "a.b.c-d.e.f" - where a-f are numbers (a.b.c is a semantic version), those are the versions in the range [a.b.c, d.e.f]
  // 2. "a.b.c-inf" - where we don't give an upper limit to the version range, those are the versions in the range [a.b.c, inf)
  const versions = versionRange.split('-');

  if (versions.length !== 2) {
    return false;
  }

  const rawLowerBoundVersion = versions[0];
  const rawUpperBoundVersion = versions[1];

  if (rawUpperBoundVersion === "inf") {
    const lowerBoundVersion = parseVersion(rawLowerBoundVersion);
    return lowerBoundVersion && isVersionBiggerOrEqual(ourVersion, lowerBoundVersion);
  } else {
    const lowerBoundVersion = parseVersion(rawLowerBoundVersion);
    const upperBoundVersion = parseVersion(rawUpperBoundVersion);
    return lowerBoundVersion && upperBoundVersion && isVersionBiggerOrEqual(ourVersion, lowerBoundVersion) && isVersionBiggerOrEqual(upperBoundVersion, ourVersion);
  }
}

function isVerifiedNodeVersion(nodeVersions) {
  const nodeVersionString = process.versions.node;
  const nodeVersion = parseVersion(nodeVersionString);

  if (nodeVersion === undefined) {
    _logger.logger.debug("Failed to parse node version");

    return false;
  }

  for (const nodeVersionRange of nodeVersions) {
    if (isInVersionRange(nodeVersionRange, nodeVersion)) {
      return true;
    }
  }

  _logger.logger.debug(`Node version is not verified for this sdk version. SDK Version: ${"0.132.0"}, node version: ${nodeVersionString}`);

  return false;
}

function isVersionDeprecated() {
  var _process$versions;

  if ((process === null || process === void 0 ? void 0 : (_process$versions = process.versions) === null || _process$versions === void 0 ? void 0 : _process$versions.node) === undefined) {
    return false;
  }

  const nodeVersionString = process.versions.node;
  const nodeVersion = parseVersion(nodeVersionString);

  if (nodeVersion === undefined) {
    return false;
  }

  const majorVersion = nodeVersion[0];
  return majorVersion <= 8;
}

function isVersionSupported() {
  var _process$versions2;

  if ((process === null || process === void 0 ? void 0 : (_process$versions2 = process.versions) === null || _process$versions2 === void 0 ? void 0 : _process$versions2.node) === undefined) {
    return false;
  }

  return isVerifiedNodeVersion(hardcodedSupportedVersions);
}

function isVersionNonLTS() {
  var _process$versions3;

  if ((process === null || process === void 0 ? void 0 : (_process$versions3 = process.versions) === null || _process$versions3 === void 0 ? void 0 : _process$versions3.node) === undefined) {
    return false;
  }

  const nodeVersionString = process.versions.node;
  const nodeVersion = parseVersion(nodeVersionString);

  if (nodeVersion === undefined) {
    return false;
  }

  const majorVersion = nodeVersion[0];
  return majorVersion >= 13 && majorVersion % 2 === 1;
}

function updateVersionSupport(rawVersions) {
  if (!config.AgentComConfiguration.SKIP_NODE_VERSION_VERIFICATION) {
    var _process$versions4;

    const parsedVersions = JSON.parse(rawVersions);
    const sdkVersion = parseVersion("0.132.0");

    if (sdkVersion === undefined) {
      _logger.logger.debug("Bad SDK Version");

      config.DebuggerService.IS_SUPPORTED = false;
      return;
    }

    if ((process === null || process === void 0 ? void 0 : (_process$versions4 = process.versions) === null || _process$versions4 === void 0 ? void 0 : _process$versions4.node) === undefined) {
      _logger.logger.debug("Missing node version");

      config.DebuggerService.IS_SUPPORTED = false;
      return;
    } // Each key of the JSON object is an SDK version range (see `isInVersionRange` for format)


    for (const sdkVersionRange of Object.keys(parsedVersions)) {
      if (isInVersionRange(sdkVersionRange, sdkVersion)) {
        // Each value is a list of node version ranges
        const nodeVersions = parsedVersions[sdkVersionRange];
        const isSupported = isVerifiedNodeVersion(nodeVersions);

        if (isSupported) {
          config.DebuggerService.IS_SUPPORTED = true;
          return;
        }
      }
    }

    config.DebuggerService.IS_SUPPORTED = false;
  }
}