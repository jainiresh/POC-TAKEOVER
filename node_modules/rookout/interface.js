'use strict';

var _utils = require("./utils");

var _exceptions = require("./exceptions");

var _sanitize = require("./sanitize");

const util = require('util');

const config = require('./config');

const {
  RookMissingToken,
  RookInvalidToken,
  RookInvalidOptions,
  RookOldServers
} = require('./exceptions');

class Rook {
  constructor() {
    this.savedOptions = null;
  }

  static _print_options(options = {}) {
    try {
      let config_string = "";

      for (let key in options) {
        if (options[key] !== undefined) {
          config_string = config_string + key + ": " + JSON.stringify(options[key]) + ", ";
        }
      }

      console.log("RookOptions: " + config_string);
    } catch (e) {}
  }

  static _verifyBoolean(object, errorString) {
    if (!(typeof object === 'boolean')) {
      throw new RookInvalidOptions(errorString);
    }
  }

  static _verifyString(object, errorString) {
    if (!(typeof object === 'string' || object instanceof String)) {
      throw new RookInvalidOptions(errorString);
    }
  }

  static _verifyToken(object) {
    Rook._verifyString(object, 'Rookout token should be a String');

    if (object.length !== 64) {
      throw new RookInvalidOptions('Rookout token should be 64 characters');
    }

    if (/^[0-9a-zA-Z]+$/.test(object) === false) {
      throw new RookInvalidOptions('Rookout token must consist of only hexadecimal characters');
    }
  }

  static _verifyLabel(label) {
    if (label.startsWith("$")) {
      throw new _exceptions.RookInvalidLabel(label);
    }
  }

  static parseSourcesList(sourcesList) {
    if (sourcesList === undefined) {
      let sources = process.env.ROOKOUT_SOURCES;

      if (sources !== undefined) {
        sourcesList = {};

        for (let source of sources.replace(/['"]/g, '').split(';')) {
          let kv = source.split('#');

          if (kv.length === 2) {
            let origin = kv[0];
            let revision = kv[1];

            if (origin && revision) {
              sourcesList[origin] = revision;
            }
          }
        }
      }
    } else {
      // Normalize the map to native dictionary
      if (sourcesList instanceof Map) {
        let originalSources = sourcesList;
        sourcesList = {};

        for (let [origin, revision] of originalSources) {
          sourcesList[origin] = revision;
        }
      }

      for (let origin of Object.keys(sourcesList)) {
        Rook._verifyString(origin, 'Remote origin in source list should be a string');

        Rook._verifyString(sourcesList[origin], 'Revision in source list should be a string');
      }
    }

    return sourcesList;
  }

  envVarsUpdate(options) {
    if (options.quiet === undefined && process.env.ROOKOUT_QUIET !== undefined) {
      options.quiet = (0, _utils.isBooleanValue)(process.env.ROOKOUT_QUIET);
    }

    if (options.log_to_stderr === undefined && process.env.ROOKOUT_LOG_TO_STDERR !== undefined) {
      options.log_to_stderr = (0, _utils.isBooleanValue)(process.env.ROOKOUT_LOG_TO_STDERR);
    }

    if (options.ignore_node_modules === undefined && process.env.ROOKOUT_IGNORE_NODE_MODULES !== undefined) {
      options.ignore_node_modules = (0, _utils.isBooleanValue)(process.env.ROOKOUT_IGNORE_NODE_MODULES);
    }

    if (options.sourcemap_debug === undefined && process.env.ROOKOUT_SOURCEMAP_DEBUG !== undefined) {
      options.sourcemap_debug = (0, _utils.isBooleanValue)(process.env.ROOKOUT_SOURCEMAP_DEBUG);
    }

    if (options.log_file === undefined && process.env.ROOKOUT_LOG_FILE !== undefined) {
      options.log_file = process.env.ROOKOUT_LOG_FILE;
    }

    if (process.env.LAMBDA_TASK_ROOT) {
      options.log_file = "";

      if (options.lambda_safe_start !== true) {
        throw new _exceptions.RookIllegalLambdaStart();
      }
    }

    options.log_level = options.log_level || process.env.ROOKOUT_LOG_LEVEL;
  }

  resolveConfigSources(optionValue, envVarName, confValue) {
    return optionValue || process.env[envVarName] || confValue;
  }

  resolveServicesConfig(options) {
    config.MonitorConfiguration.ENABLED = this.resolveConfigSources(options.enable_monitor, "ROOKOUT_ENABLE_MONITOR", config.MonitorConfiguration.ENABLED);
    config.MemoryUsageLogService.ENABLED = this.resolveConfigSources(options.enable_memory_usage_log, "ROOKOUT_ENABLE_MEMORY_USAGE_LOG", config.MemoryUsageLogService.ENABLED);
    config.MemoryUsageLogService.LOG_FILE = this.resolveConfigSources(options.memory_usage_log_file, "ROOKOUT_MEMORY_USAGE_LOG_FILE", config.MemoryUsageLogService.LOG_FILE);
    config.MemoryUsageLogService.TRACE_GC_ENABLED = this.resolveConfigSources(options.enable_trace_gc, "ROOKOUT_ENABLE_TRACE_GC", config.MemoryUsageLogService.TRACE_GC_ENABLED);
    const legacyLiveTailEnvVar = process.env.ROOKOUT_LIVE_TAIL;
    const liveTailEnvVar = process.env.ROOKOUT_LIVE_LOGGER;
    const consoleLiveLoggerEnvVar = options.console_live_logger || process.env.ROOKOUT_CONSOLE_LIVE_LOGGER;
    const liveTailProp = options.live_logger;
    const legacyLiveTailProp = options.enable_livetail;
    const enableLiveTail = liveTailProp || legacyLiveTailProp || liveTailEnvVar || legacyLiveTailEnvVar || consoleLiveLoggerEnvVar || config.LogHandlerService.ENABLED || config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED;
    config.LogHandlerService.ENABLED = enableLiveTail;

    if (enableLiveTail) {
      config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED = consoleLiveLoggerEnvVar || config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED;
      options.labels["live_logger"] = "on";
    }
  }

  startServices(options) {
    this.resolveServicesConfig(options);

    require('./singleton').singleton.startServices();
  }

  start(options = {}) {
    if (Object.keys(options).length === 0 && this.savedOptions !== null) {
      options = this.savedOptions;
    }

    let self = this;
    this.startAttempted = true;
    (0, _sanitize.sanitize)(options);
    (0, _sanitize.sanitize)(process.env, true); // We want the services to start synchronously, so this part is outside the promise

    try {
      self.debug = false;

      if (options.debug === undefined) {
        self.debug = (0, _utils.isBooleanValue)(process.env.ROOKOUT_DEBUG);
      } else {
        self.debug = options.debug;
      }

      self.throw_errors = false;

      if (options.throw_errors !== undefined) {
        self.throw_errors = options.throw_errors;
      }

      if (options.quiet !== undefined) {
        Rook._verifyBoolean(options.quiet, 'Rook quiet should be a boolean');

        config.LoggingConfiguration.QUIET = options.quiet;
      }

      if (options.log_to_stderr !== undefined) {
        Rook._verifyBoolean(options.log_to_stderr, 'Rook log to stderr should be a boolean');

        config.LoggingConfiguration.LOG_TO_STDERR = options.log_to_stderr;
      }

      if (options.sourcemap_debug !== undefined) {
        Rook._verifyBoolean(options.sourcemap_debug, 'Rook sourcemap debug should be a boolean');

        config.LoggingConfiguration.ROOKOUT_SOURCEMAP_DEBUG = options.sourcemap_debug;
      }

      if (options.log_level !== undefined) {
        Rook._verifyString(options.log_level, 'Rook log level should be a String');

        config.LoggingConfiguration.LOG_LEVEL = options.log_level;
      }

      if (options.log_file !== undefined) {
        Rook._verifyString(options.log_file, 'Rook log file should be a String');

        config.LoggingConfiguration.FILE_NAME = options.log_file;
      }

      Rook._verifyBoolean(self.throw_errors, 'Rook throw errors should be a boolean');

      Rook._verifyBoolean(self.debug, 'Rook debug flag should be a boolean');

      if (self.debug) {
        config.LoggingConfiguration.LOG_LEVEL = 'DEBUG';
        config.LoggingConfiguration.LOG_TO_STDERR = true;
        config.LoggingConfiguration.DEBUG = true;
      }

      if (options.labels === undefined) {
        options.labels = {};
        let labels = process.env.ROOKOUT_LABELS;

        if (labels !== undefined) {
          for (let label of labels.replace(/['"]/g, '').split(',')) {
            let kv = label.split(':');

            if (kv.length === 2) {
              let key = kv[0];
              let value = kv[1];

              if (key && value) {
                options.labels[key] = value;
              }
            }
          }
        }
      } else {
        // Normalize the map to native dictionary
        if (options.labels instanceof Map) {
          let originalLabels = options.labels;
          options.labels = {};

          for (let [key, value] of originalLabels) {
            options.labels[key] = value;
          }
        }

        for (let label of Object.keys(options.labels)) {
          // Set the label as an empty string if NULL
          if (options.labels[label] === undefined || options.labels[label] === null) {
            options.labels[label] = "";
          }

          Rook._verifyString(label);

          Rook._verifyString(options.labels[label], 'Rook label should be a map of strings');

          Rook._verifyLabel(label);
        }
      }

      this.startServices(options);
    } catch (e) {
      if (self.throw_errors) {
        return Promise.reject(e);
      } else {
        console.error('[Rookout] Failed to start Rookout: ', e.message);

        if (self.debug) {
          console.error(e.stack || e);
        }

        return Promise.resolve();
      }
    }

    return new Promise((resolve, reject) => {
      try {
        if (self.singleton) resolve();
        self.envVarsUpdate(options);
        const envSkipNodeWhitelist = (0, _utils.isBooleanValue)(process.env.ROOKOUT_SKIP_NODE_WHITELIST);

        if (options.skip_node_whitelist || envSkipNodeWhitelist) {
          config.AgentComConfiguration.SKIP_NODE_VERSION_VERIFICATION = true;
        } else {
          config.AgentComConfiguration.SKIP_NODE_VERSION_VERIFICATION = false;

          const nodeVersionSupport = require("./nodeVersionSupport");

          config.DebuggerService.IS_SUPPORTED = nodeVersionSupport.isVersionSupported();
          config.DebuggerService.IS_DEPRECATED = nodeVersionSupport.isVersionDeprecated();
          config.DebuggerService.IS_NON_LTS = nodeVersionSupport.isVersionNonLTS();
        }

        if (options.skip_ssl_verification === undefined && process.env.ROOKOUT_SKIP_SSL_VERIFY !== undefined) {
          config.AgentComConfiguration.SKIP_SSL_CERTIFICATE_VERIFICATION = (0, _utils.isBooleanValue)(process.env.ROOKOUT_SKIP_SSL_VERIFY);
        }

        if (process.env.ROOKOUT_BREAKPOINT_FAILSAFE !== undefined) {
          config.InstrumentationConfig.EMPTY_HITBREAKPOINTS_FAILSAFE = (0, _utils.isBooleanValue)(process.env.ROOKOUT_BREAKPOINT_FAILSAFE);
        }

        if (options.quick !== undefined) {
          Rook._verifyBoolean(options.quick, 'Rook quick should be a boolean');

          config.InstrumentationConfig.QUICK_START = options.quick;
        }

        if (options.ignore_node_modules !== undefined) {
          Rook._verifyBoolean(options.ignore_node_modules, 'Rook ignore node modules should be a boolean');

          config.SourceFiles.IGNORE_NODE_MODULES = options.ignore_node_modules;
        }

        if (options.tags === undefined) {
          let rawTags = process.env.ROOKOUT_ROOK_TAGS;

          if (rawTags !== undefined) {
            options.tags = [];

            for (let tag of rawTags.replace(/['"]/g, '').split(';')) {
              options.tags.push(_utils.StringUtils.trim(tag));
            }
          }
        } else {
          if (Array.isArray(options.tags)) {
            for (let tag of options.tags) {
              Rook._verifyString(tag, 'Rook tags should be array of strings');
            }
          } else {
            throw new RookInvalidOptions('Rook tags should be array of strings');
          }
        }

        if (options.git_commit !== undefined) {
          Rook._verifyString(options.git_commit, 'Git commit should be a String');

          config.GitConfiguration.GIT_COMMIT = options.git_commit;
        }

        if (options.git_origin !== undefined) {
          Rook._verifyString(options.git_origin, 'Git origin should be a String');

          config.GitConfiguration.GIT_ORIGIN = options.git_origin;
        }

        options.sources = Rook.parseSourcesList(options.sources);

        if (options.sources !== undefined) {
          config.GitConfiguration.SOURCES = options.sources;
        }

        config.InstrumentationConfig.MAX_SCRIPTS_COUNT_FAIL_SAFE = this.resolveConfigSources(options.maxScriptsFailSafe, "ROOKOUT_MAX_SCRIPTS_COUNT_FAIL_SAFE", config.InstrumentationConfig.MAX_SCRIPTS_COUNT_FAIL_SAFE);
        config.InstrumentationConfig.MAX_SCRIPTS_SIZE_FAIL_SAFE = this.resolveConfigSources(options.maxScriptsSizeFailSafe, "ROOKOUT_MAX_SCRIPTS_SIZE_FAIL_SAFE", config.InstrumentationConfig.MAX_SCRIPTS_SIZE_FAIL_SAFE);
        let heapSnapshotsDirectory = this.resolveConfigSources(options.heap_snapshots_directory, "ROOKOUT_HEAP_SNAPSHOTS_DIRECTORY", false);

        if (heapSnapshotsDirectory) {
          config.HeapSnapshotConfiguration.HEAP_PATH = heapSnapshotsDirectory;
          config.HeapSnapshotConfiguration.SIGNAL = this.resolveConfigSources(options.heap_snapshots_signal, "ROOKOUT_HEAP_SNAPSHOTS_SIGNAL", config.HeapSnapshotConfiguration.SIGNAL);
        }

        let host = options.host || process.env.ROOKOUT_CONTROLLER_HOST || process.env.ROOKOUT_AGENT_HOST;
        let port = options.port || process.env.ROOKOUT_CONTROLLER_PORT || process.env.ROOKOUT_AGENT_PORT;
        let proxy = options.proxy || process.env.ROOKOUT_PROXY;
        let token = options.token || process.env.ROOKOUT_TOKEN;

        if (proxy !== undefined) {
          Rook._verifyString(proxy, 'proxy should be a string');
        }

        const {
          logger
        } = require('./logger');

        self.singleton = require('./singleton').singleton;
        config.Tracing.ENABLED = self.singleton.triggerServices.getService('TracingService') !== undefined;

        if (!config.Tracing.ENABLED) {
          logger.debug("Disabling tracing, hooking failed.");
        } else {
          var _self$singleton$trigg;

          const label = (_self$singleton$trigg = self.singleton.triggerServices.getService('TracingService')) === null || _self$singleton$trigg === void 0 ? void 0 : _self$singleton$trigg.getLabelName();

          if (label !== undefined) {
            options.labels[label] = 'on';
          }
        }

        const msg = util.format('Rookout SDK [%s]:[%s] for NodeJS [%s]', config.VersionConfiguration.VERSION, config.VersionConfiguration.COMMIT, process.versions.node);
        logger.debug(msg);

        if (config.InstrumentationConfig.QUICK_START) {
          logger.debug("Rookout started in quick mode");
        }

        if (host === undefined && token === undefined) {
          throw new RookMissingToken();
        } else {
          if (token !== undefined) {
            Rook._verifyToken(token);
          }
        }

        if (this.debug) {
          Rook._print_options({
            token: token !== undefined ? token.substring(0, 5) + "....." : undefined,
            host: host,
            port: port,
            proxy: proxy,
            throw_errors: self.throw_errors,
            log_level: options.log_level,
            log_to_stderr: options.log_to_stderr,
            log_file: options.log_file,
            git_commit: options.git_commit,
            git_origin: options.git_origin,
            sources: options.sources,
            tags: options.tags,
            live_logger: options.live_logger,
            labels: options.labels,
            quick: options.quick,
            quiet: options.quiet
          });
        }

        host = host || config.ControllerAddress.HOST;
        host = host.replace(/\/+$/, '');

        Rook._verifyString(host, 'Rook host should be String');

        if (host === "staging.cloud.agent.rookout.com" || host === "cloud.agent.rookout.com") {
          throw new RookOldServers();
        }

        port = port || config.ControllerAddress.PORT;

        if (!(typeof port === 'number' || typeof port === 'string')) {
          throw new RookInvalidOptions('Rook port should be a Number or a String');
        }

        if (process.env.ROOKOUT_CONNECTION_TIMEOUT !== undefined) {
          if (typeof process.env.ROOKOUT_CONNECTION_TIMEOUT === 'number') {
            config.AgentComConfiguration.TIMEOUT = process.env.ROOKOUT_CONNECTION_TIMEOUT;
          }
        }

        this.savedOptions = options;
        self.singleton.connect(token, host, port, proxy, options.tags, options.labels, !options.quick, this.debug, this.throw_errors).catch(e => {
          if (self.throw_errors) {
            reject(e);
          } else {
            if (e instanceof RookInvalidToken || e instanceof RookOldServers || e instanceof _exceptions.RookIllegalLambdaStart || e instanceof _exceptions.RookWebSocketError) {
              console.log('[Rookout] ', e.message);
            } else {
              logger.warn('[Rookout] Failed to connect to the controller - will continue attempting in the background: ', e.message);
            }

            if (self.debug) {
              console.error(e.stack || e);
            }

            resolve(self);
          }
        }).then(() => resolve(self));
      } catch (e) {
        if (self.throw_errors) {
          reject(e);
        } else {
          console.error('[Rookout] Failed to start Rookout: ', e.message);

          if (self.debug) {
            console.error(e.stack || e);
          }

          resolve(self);
        }
      }
    });
  }

  async stop() {
    if (!this.singleton) return;

    try {
      const singleton = this.singleton;
      this.singleton = undefined;
      await singleton.close();
    } catch (e) {
      if (this.throw_errors) {
        throw e;
      }

      if (this.debug) {
        console.error(e.stack || e);
      }
    }
  }

  flush(callback) {
    const retVal = new Promise(resolve => {
      if (!this.singleton) {
        resolve();
      }

      try {
        this.singleton.flush(resolve);
      } catch (e) {
        if (this.debug) {
          console.error(e.stack || e);
        }

        resolve();
      }
    });

    if (callback !== undefined) {
      retVal.then(callback);
    }

    return retVal;
  }

  takeSnapshot(message, obj = undefined) {
    const execute = require('./services/dummies/AnchorLinesServiceDummy');

    let url = {};
    execute();
    return url.url;
  }

}

module.exports = Rook;