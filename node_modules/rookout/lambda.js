'use strict';

const trueValues = ['y', 'Y', 'yes', 'Yes', 'YES', 'true', 'True', 'TRUE', '1', true];

class RookoutLambdaWrapper {
  constructor(rookout, originalThis, originalFunction, originalEvent, originalContext, originalCallback) {
    this.rookout = rookout;
    this.originalThis = originalThis;
    this.originalFunction = originalFunction;
    this.originalEvent = originalEvent;
    this.originalContext = originalContext;
    this.originalCallback = originalCallback;
    this.callbackCalled = false;
    this.originalFunctionReturnedPromise = false; // The constructor is called _after_ `rookout.start`, but imported _before_ `rookout.start` --
    // importing the logger in this file means it'll be initialized too early.

    this.logger = require("./logger").logger;
    const originalDone = this.originalContext.done;
    const originalFail = this.originalContext.fail;
    const originalSucceed = this.originalContext.succeed;

    const flusher = cb => {
      try {
        this.flush(cb);
      } catch (e) {}
    };

    this.originalContext.done = (error, result) => {
      // this === context
      flusher(() => {
        originalDone.call(originalContext, error, result);
      });
    };

    this.originalContext.fail = error => {
      flusher(() => {
        originalFail.call(originalContext, error);
      });
    };

    this.originalContext.succeed = result => {
      flusher(() => {
        originalSucceed.call(originalContext, result);
      });
    };
  }

  callback(err, result) {
    this.boundCallback = this.originalCallback.bind(this.originalThis, err, result);
    this.callbackCalled = true;
    this.flush(() => {
      if (!this.originalFunctionReturnedPromise) {
        this.boundCallback();
      }
    });
  }

  invoke() {
    let result = this.originalFunction.call(this.originalThis, this.originalEvent, this.originalContext, this.callback.bind(this));
    const self = this;

    if (result !== undefined && result.then !== undefined) {
      this.originalFunctionReturnedPromise = true;
      return new Promise((resolve, reject) => {
        result.then(value => {
          self.flush(() => {
            // The user might have returned a Promise/used an async function *and* called the callback.
            if (this.callbackCalled) {
              self.logger.debug("Calling AWS callback from invoke promise resolve handler");
              this.boundCallback();
            }

            self.logger.debug("Resolving with result: %s", value);
            resolve(value);
          });
        }).catch(err => {
          self.flush(() => {
            // The user might have returned a Promise/used an async function *and* called the callback.
            if (this.callbackCalled) {
              self.logger.debug("Calling AWS callback from invoke promise reject handler");
              this.boundCallback();
            }

            reject(err);
          });
        });
      });
    } else {
      this.flush();
      return result;
    }
  }

  flush(callback) {
    if (this.rookout) {
      const timeout = setTimeout(() => {
        if (null !== callback && undefined !== callback) {
          callback();
          callback = null;
        }
      }, 250);
      this.rookout.flush().then(() => {
        clearTimeout(timeout);

        if (null !== callback && undefined !== callback) {
          callback();
          callback = null;
        }
      }).catch(() => {});
    }
  }

}

let invokeAndChain = (wrapper, resolve, reject) => {
  try {
    let invoke_result = wrapper.invoke();

    if (invoke_result !== undefined && invoke_result.then !== undefined) {
      invoke_result.then(value => resolve(value)).catch(err => {
        reject(err);
      });
    } else {// intentionally empty - we must not resolve the promise so that the lambda only ends after timeout
      // or when the callback is called
    }
  } catch (err) {
    reject(err);
  }
};

exports.wrap = (originalFunction, options = {}) => {
  if (!process.env.LAMBDA_TASK_ROOT) {
    return originalFunction;
  }

  if (options.quick === undefined && process.env.ROOKOUT_LAMBDA_QUICK_START !== undefined) {
    options.quick = trueValues.indexOf(process.env.ROOKOUT_LAMBDA_QUICK_START) !== -1;
  }

  const rook = require('.'); // An already-resolved Promise


  let startRook = Promise.resolve();

  if (!rook.startAttempted) {
    options.log_file = options.log_file || "";
    options.lambda_safe_start = true;

    if (!options.quick) {
      startRook = rook.start(options);
    } else {
      //quick mode means that we just shove the rook start to the event loop to be handled later
      //this allows faster cold start
      Promise.resolve(rook.start(options));
    }
  }

  return (event, context, callback) => {
    let wrapper = new RookoutLambdaWrapper(rook, void 0, originalFunction, event, context, callback);
    return new Promise((resolve, reject) => {
      startRook.then(() => invokeAndChain(wrapper, resolve, reject)).catch(() => invokeAndChain(wrapper, resolve, reject));
    });
  };
};