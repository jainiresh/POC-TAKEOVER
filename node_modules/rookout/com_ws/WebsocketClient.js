"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ws = _interopRequireDefault(require("ws"));

var _logger = require("../logger");

var _exceptions = require("../exceptions");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const config = require("../config");

class WebsocketClient {
  constructor(url, proxy, token) {
    this.url = url;
    this.proxy = proxy;
    this.token = token;
    this._connection = null;
    this._resolve = null;
    this._reject = null;
    this._error = null;
    this._messages = [];
    this._connectTimeout = null;
    this._pingInterval = null;
    this._pingTimeout = null;
  }

  connect() {
    return new Promise((resolve, reject) => {
      try {
        this.setPromiseHandlers(resolve, reject);
        this._connection = new _ws.default(this.url, [], {
          headers: {
            "User-Agent": `RookoutAgent/${config.VersionConfiguration.VERSION}+${config.VersionConfiguration.COMMIT}`,
            "X-Rookout-Token": this.token
          },
          agent: this.buildProxy(),
          perMessageDeflate: false,
          rejectUnauthorized: !config.AgentComConfiguration.SKIP_SSL_CERTIFICATE_VERIFICATION
        });
        this.setConnectTimeout();
        this.setResponseListeners();
      } catch (e) {
        reject(e);
      }
    });
  }

  isConnected() {
    return this._connection && this._connection.readyState === _ws.default.OPEN;
  }

  read() {
    return new Promise((resolve, reject) => {
      try {
        if (this._error) {
          const error = this._error;
          this._error = null;
          reject(error);
        }

        const message = this._messages.shift();

        if (message) {
          resolve(message);
        }

        this.setPromiseHandlers(resolve, reject);
      } catch (e) {
        reject(e);
      }
    });
  }

  sendInner(message, timeout, resolve, reject) {
    this._connection.send(message, {
      binary: true
    }, err => {
      if (err) {
        reject(new _exceptions.RookSendFailedError());
      } else {
        resolve(); // send was successful
      }

      clearTimeout(timeout);
    });
  } // DON'T LOG HERE - THIS FUNCTION IS INDIRECTLY CALLED FROM WITHIN THE LOGGER
  // LOGGING HERE LEADS TO INFINITE RECURSION


  send(message) {
    return new Promise((resolve, reject) => {
      try {
        if (this._connection) {
          // For cases the callback was not called
          const timeout = setTimeout(() => {
            reject(new _exceptions.RookSendFailedError());
          }, config.AgentComConfiguration.SEND_RESOLVE_TIMEOUT);
          (0, _utils.nodeUnref)(timeout);
          this.sendInner(message, timeout, resolve, reject);
        } else {
          reject(new _exceptions.RookNotConnectedError());
        }
      } catch (e) {
        reject(e);
      }
    });
  }

  terminateConnection() {
    if (this._connection) {
      this._connection.terminate();
    }

    this._connection = null;
  }

  close() {
    this.terminateConnection();
    this.clearPingTimeout();
    this.clearPingInterval();
    this.clearConnectTimeout();
  }

  buildProxy() {
    if (this.proxy === null) {
      return false;
    }

    const HttpsProxyAgent = require('https-proxy-agent');

    _logger.logger.debug("Connecting via proxy: %s", this.proxy);

    if (this.proxy.startsWith("http")) {
      return HttpsProxyAgent(this.proxy);
    } else {
      return HttpsProxyAgent("http://" + this.proxy);
    }
  }

  setResponseListeners() {
    // Heartbeat runs on every ping and pong, as well as once on a new connection.
    this._connection.on("open", () => {
      try {
        _logger.logger.debug("Connection established");

        this.clearConnectTimeout(); // The socket does not exist before this point except internally - we can't access it.
        // Upon a connection timeout (currently 2 seconds), the socket will be terminated.

        if (this._connection) {
          (0, _utils.nodeUnref)(this._connection._socket);
        } // Set up pinging


        this.setPingInterval();
        this.heartbeat();
        this.returnConnected();
      } catch (e) {}
    });

    this._connection.on("ping", () => {
      try {
        this.heartbeat();
      } catch (e) {}
    });

    this._connection.on("pong", () => {
      try {
        this.heartbeat();
      } catch (e) {}
    });

    this._connection.on("close", () => {
      try {
        this.returnError('Connection closed');
      } catch (e) {}
    });

    this._connection.on("message", msg => {
      try {
        this.returnMessage(msg);
      } catch (e) {}
    });

    this._connection.on("error", err => {
      try {
        this.returnError(err);
      } catch (e) {}
    }); // Unexpected HTTP responses


    this._connection.on("unexpected-response", (req, resp) => {
      try {
        this.returnError({
          statusCode: resp.statusCode
        });
      } catch (e) {}
    });
  }

  setPromiseHandlers(resolve, reject) {
    this._resolve = resolve;
    this._reject = reject;
  }

  returnConnected() {
    if (!this._resolve) {
      _logger.logger.warn("Failed to return connected status");
    }

    const resolve = this._resolve;
    this.clearPromiseHandlers();
    resolve();
  }

  returnError(error) {
    this._error = error;

    if (this._reject) {
      const reject = this._reject;
      this.clearPromiseHandlers();
      reject(error);
    }
  }

  returnMessage(message) {
    if (this._resolve) {
      const resolve = this._resolve;
      this.clearPromiseHandlers();
      resolve(message);
    } else {
      if (this._messages.length > config.AgentComConfiguration.MAX_QUEUED_MESSAGES) {
        _logger.logger.warn("Too many incoming messages, discarding");

        return;
      }

      this._messages.push(message);
    }
  }

  clearPromiseHandlers() {
    this._resolve = null;
    this._reject = null;
  }

  setConnectTimeout() {
    this.clearConnectTimeout();
    this._connectTimeout = setTimeout(() => {
      try {
        _logger.logger.error("WS connect timeout, closing connection");

        if (this._connection) {
          this.terminateConnection();
          this._connection = null;
        }
      } catch (e) {}
    }, config.AgentComConfiguration.CONNECT_TIMEOUT * 1000);
    (0, _utils.nodeUnref)(this._connectTimeout);
  }

  clearConnectTimeout() {
    if (this._connectTimeout) {
      clearTimeout(this._connectTimeout);
      this._connectTimeout = null;
    }
  }

  resetPingTimeout() {
    this.clearPingTimeout();
    this._pingTimeout = setTimeout(() => {
      try {
        _logger.logger.error("WS ping timeout, closing connection");

        if (this._connection) {
          this.terminateConnection();
          this._connection = null;
        }
      } catch (e) {}
    }, config.AgentComConfiguration.PING_TIMEOUT * 1000);
    (0, _utils.nodeUnref)(this._pingTimeout);
  }

  clearPingTimeout() {
    if (this._pingTimeout) {
      clearTimeout(this._pingTimeout);
      this._pingTimeout = null;
    }
  }

  setPingInterval() {
    if (this._pingInterval) {
      return;
    }

    this._pingInterval = setInterval(() => {
      try {
        if (this._connection && this._connection.readyState === _ws.default.OPEN) {
          this._connection.ping(() => {});
        }
      } catch (e) {}
    }, config.AgentComConfiguration.PING_INTERVAL * 1000);
    (0, _utils.nodeUnref)(this._pingInterval);
  }

  clearPingInterval() {
    if (this._pingInterval) {
      clearInterval(this._pingInterval);
      this._pingInterval = null;
    }
  }

  heartbeat() {
    this.resetPingTimeout();
  }

}

exports.default = WebsocketClient;