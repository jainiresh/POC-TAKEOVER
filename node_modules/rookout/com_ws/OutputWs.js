"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NamespaceSerializer = _interopRequireDefault(require("../processor/NamespaceSerializer"));

var _logger = require("../logger");

var _TokenBucket = _interopRequireDefault(require("./TokenBucket"));

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _exceptions = require("../exceptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const config = require("../config");

const messages_pb = require("../protobuf/messages_pb");

const timestamp_pb = require("google-protobuf/google/protobuf/timestamp_pb"); // Maps logger.js:LOG_LEVELS to the LogMessage enum


const LOG_LEVELS = {
  0: messages_pb.LogMessage.LogLevel.DEBUG,
  1: messages_pb.LogMessage.LogLevel.INFO,
  2: messages_pb.LogMessage.LogLevel.WARNING,
  3: messages_pb.LogMessage.LogLevel.ERROR,
  4: messages_pb.LogMessage.LogLevel.FATAL
};

class OutputWs {
  constructor(id) {
    this.id = id;
    this._agentCom = null; // augIds of augs we skipped collection of because the output queue was full

    this.skippedAugIds = new Set();
    this._ruleStatusUpdatesBucket = new _TokenBucket.default(config.OutputWsConfiguration.MAX_STATUS_UPDATES, config.OutputWsConfiguration.BUCKET_REFRESH_RATE, () => _logger.logger.error("Limit reached, dropping status updates"));
    this._userMessageBucket = new _TokenBucket.default(config.OutputWsConfiguration.MAX_AUG_MESSAGES, config.OutputWsConfiguration.BUCKET_REFRESH_RATE, () => _logger.logger.error("Limit reached, dropping aug report messages"));
    this._logMessageBucket = new _TokenBucket.default(config.OutputWsConfiguration.MAX_LOG_ITEMS, config.OutputWsConfiguration.BUCKET_REFRESH_RATE, () => this._internalSendLogMessage(3, __filename, 0, "Limit reached, dropping log messages", "Limit reached, dropping log messages"));

    _logger.logger.registerOutput(this);
  }

  setAgentCom(agentCom) {
    this._agentCom = agentCom;
  }

  flushMessages(callback) {
    let msgsFlushedPromise = this._agentCom.flushMessages();

    msgsFlushedPromise.then(callback).catch(callback);
  }

  sendRuleStatus(ruleId, active, error) {
    if (!this._agentCom) {
      return;
    }

    this._ruleStatusUpdatesBucket.doIfAvailable(() => {
      if (active === "Deleted") {
        this.skippedAugIds.delete(ruleId);
      }

      let ruleStatusMessage = new messages_pb.RuleStatusMessage();
      ruleStatusMessage.setAgentId(this.id);
      ruleStatusMessage.setRuleId(ruleId);
      ruleStatusMessage.setActive(active);

      if (error) {
        ruleStatusMessage.setError(error.dumps());
      }

      try {
        this.addMessage(ruleId, ruleStatusMessage);
      } catch (e) {
        if (e instanceof _exceptions.RookOutputQueueFull) {} else {
          throw e;
        }
      }
    });
  }

  sendUserMessage(augId, messageId, args) {
    if (!this._agentCom) {
      return;
    }

    this._userMessageBucket.doIfAvailable(() => {
      if (config.OutputWsConfiguration.PROTOBUF_VERSION2) {
        try {
          this._agentCom.sendUserMessage(augId, messageId, args);
        } catch (e) {
          _logger.logger.exception(e);

          if (e instanceof _RookError.default && !(e instanceof _exceptions.RookOutputQueueFull)) {
            this.sendError(augId, e);
          } else {
            throw e;
          }
        }
      } else {
        let msg = new messages_pb.AugReportMessage();
        msg.setAgentId(this.id);
        msg.setAugId(augId);
        msg.setReportId(messageId);

        if (args) {
          let namespaceSerializer = new _NamespaceSerializer.default(config.DumpConfig.STRING_CACHE_USERMESSAGE);
          msg.setArguments(namespaceSerializer.dumps(args));
          let stringCacheMap = msg.getStringsCacheMap();
          let stringCache = namespaceSerializer.getStringCache();
          Object.keys(stringCache).forEach(key => {
            stringCacheMap.set(key, stringCache[key]);
          });
        }

        this.addMessage(augId, msg);
        this.skippedAugIds.delete(augId);
      }
    });
  }

  areUserMessagesFull() {
    return this._userMessageBucket.isExhausted() || this._agentCom && this._agentCom.isQueueFull();
  }

  sendOutputQueueFullWarning(augId) {
    var _this$_agentCom, _this$_agentCom2, _this$_agentCom2$_pen;

    if (this.skippedAugIds.has(augId)) {
      return;
    }

    this.skippedAugIds.add(augId);
    this.sendRuleStatus(augId, "Warning", new _RookError.default(new _exceptions.RookOutputQueueFull(0, ((_this$_agentCom = this._agentCom) === null || _this$_agentCom === void 0 ? void 0 : _this$_agentCom._pendingMessagesSize) || 0, ((_this$_agentCom2 = this._agentCom) === null || _this$_agentCom2 === void 0 ? void 0 : (_this$_agentCom2$_pen = _this$_agentCom2._pendingMessages) === null || _this$_agentCom2$_pen === void 0 ? void 0 : _this$_agentCom2$_pen.length) || 0)));

    _logger.logger.warn(`Skipping aug (${augId}) execution because the queue is full`);
  }

  sendLogMessage(level, time, filename, lineno, text, formattedMessage, args) {
    if (!this._agentCom) {
      return;
    }

    this._logMessageBucket.doIfAvailable(() => this._internalSendLogMessage(level, filename, lineno, text, formattedMessage, args));
  }

  _internalSendLogMessage(level, filename, lineno, text, formattedMessage, args) {
    if (!this._agentCom) {
      return;
    }

    let msg = new messages_pb.LogMessage();
    let date = new timestamp_pb.Timestamp();
    date.fromDate(new Date());
    msg.setTimestamp(date);
    let logLevel = LOG_LEVELS[level];

    if (logLevel === undefined) {
      logLevel = messages_pb.LogMessage.LogLevel.WARNING;
    }

    msg.setAgentId(this.id);
    msg.setLevel(logLevel);
    msg.setFilename(filename);
    msg.setLine(lineno);
    msg.setText(text);
    msg.setFormattedMessage(formattedMessage);

    if (args) {
      msg.setLegacyArguments(new _NamespaceSerializer.default().dumps(args));
    }

    try {
      // DO NOT CHANGE TO 'addMessage' TO AVOID RECURSION LOOP
      this._agentCom.add(msg);
    } catch (e) {
      if (e instanceof _exceptions.RookOutputQueueFull) {} else {
        throw e;
      }
    }
  }

  sendWarning(ruleId, error) {
    this.sendRuleStatus(ruleId, "Warning", error);
  }

  sendError(ruleId, error) {
    this.sendRuleStatus(ruleId, "Error", error);
  }

  addMessage(ruleId, message) {
    const error = this._agentCom.add(message);

    if (error) {
      this.sendWarning(ruleId, new _RookError.default(error));
    }
  }

}

exports.default = OutputWs;