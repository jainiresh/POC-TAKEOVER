"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanupAgentInfoPromise = cleanupAgentInfoPromise;
exports.collect = collect;
exports.pack_agent_info = pack_agent_info;

var _logger = require("../logger");

var _git = _interopRequireDefault(require("../git"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const agent_info_pb = require("../protobuf/agent_info_pb");

const os = require("os");

const ip = require("ip");

const path = require("path");

const config = require('../config');

const fs = require('fs'); // Kubernetes namespace related variables


const k8sNamespaceFileName_default = '/var/run/secrets/kubernetes.io/serviceaccount/namespace';
var k8sNamespaceFileName = k8sNamespaceFileName_default;

class Information {
  constructor() {
    if (this.constructor === Information) {
      throw new TypeError("Abstract class \"Information\" cannot be instantiated directly.");
    }

    this._collectors = this._getCollectors();
  } // Override this method without calling super.

  /* abstract */


  _getCollectors() {
    throw new TypeError("Inheriting classes must implement _getCollectors");
  } // k8sNamespaceFileNameOverride - override the default read location of the Kubernetes
  // namespace information. Use for debugging.


  async collect(debug) {
    let output = {};

    for (let key of Object.keys(this._collectors)) {
      let value = this._collectors[key];

      if (value instanceof Function) {
        value = value();
      }

      output[key] = await value;
    }

    output.debug = debug;
    return output;
  }

}

class SCMInformation extends Information {
  _getCollectors() {
    return {
      "commit": this._get_commit.bind(this),
      "origin": this._get_origin.bind(this),
      "sources": this._get_sources.bind(this)
    };
  }

  _get_sources() {
    return config.GitConfiguration.SOURCES || {};
  }

  _get_commit() {
    let userCommit = config.GitConfiguration.GIT_COMMIT || process.env.ROOKOUT_COMMIT || "";

    if (userCommit === "") {
      try {
        let gitRoot = this._get_git_root();

        if (gitRoot !== "") {
          if (userCommit === "") {
            userCommit = _git.default.getRevision(gitRoot);
          }

          return userCommit;
        }
      } catch (e) {
        _logger.logger.exception("Failed to get git commit");
      }

      return "";
    }

    return userCommit;
  }

  _get_git_root() {
    let gitRoot = process.env.ROOKOUT_GIT || "";

    if (gitRoot === "") {
      // In case users starts rookout via the -r flag using rookout.js
      const filename = require.main ? require.main.filename : module.filename;
      gitRoot = _git.default.findRoot(path.dirname(path.resolve(filename)));
    }

    return gitRoot;
  }

  _get_origin() {
    let userRemoteOrigin = config.GitConfiguration.GIT_ORIGIN || process.env.ROOKOUT_REMOTE_ORIGIN || "";

    if (userRemoteOrigin === "") {
      try {
        let gitRoot = this._get_git_root();

        if (gitRoot !== "") {
          if (userRemoteOrigin === "") {
            userRemoteOrigin = _git.default.getRemoteOrigin(gitRoot);
          }

          return userRemoteOrigin;
        }
      } catch (e) {
        _logger.logger.exception("Failed to get git remote origin");
      }

      return "";
    }

    return userRemoteOrigin;
  }

}

class PlatformInformation extends Information {
  _getCollectors() {
    return {
      "platform": "node",
      "version": process.version
    };
  }

}

class NetworkInformation extends Information {
  _getCollectors() {
    return {
      "ip_addr": ip.address,
      "network": os.hostname
    };
  }

}

class SystemInformation extends Information {
  _getCollectors() {
    return {
      "hostname": os.hostname,
      "os": os.platform,
      "os_version": os.release,
      "distro": this._getDistro,
      "arch": os.arch
    };
  }

  async _getDistro() {
    return "<NA>";
  }

}

class VersionInformation extends Information {
  _getCollectors() {
    return {
      "version": "0.132.0",
      "commit": "53db6e614c35cc4197bf3e87e7602ee556484b96"
    };
  }

}

class ClusterInformation extends Information {
  _getCollectors() {
    // Check if the file exists, may also be a directory
    try {
      if (!fs.existsSync(k8sNamespaceFileName)) {
        return {
          "k8s_namespace": ""
        };
      }
    } catch (err) {
      return {
        "k8s_namespace": ""
      };
    } // If the file exists, verify it's not a directory


    try {
      var stat = fs.lstatSync(k8sNamespaceFileName);

      if (stat.isDirectory()) {
        _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' is not a directory");

        return {
          "k8s_namespace": ""
        };
      }
    } catch (err) {
      _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' status works");

      return {
        "k8s_namespace": ""
      };
    } // Read the k8s namespace from the file


    try {
      const data = fs.readFileSync(k8sNamespaceFileName, 'ascii');
      return {
        "k8s_namespace": data
      };
    } catch (err) {
      _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' is not corrupted");
    }

    return {
      "k8s_namespace": ""
    };
  }

}

class ServerlessInformation extends Information {
  isAWSLambda() {
    return process.env.AWS_LAMBDA_FUNCTION_NAME;
  }

  isGoogleCloudFunction() {
    return process.env.FUNCTION_TARGET && process.env.FUNCTION_SIGNATURE_TYPE;
  }

  isAzureFunction() {
    return process.env.FUNCTIONS_WORKER_RUNTIME && process.env.WEBSITE_SITE_NAME;
  }

  isCloudRunOrFirbase() {
    return process.env.K_SERVICE && process.env.K_REVISION && process.env.K_CONFIGURATION && process.env.PORT;
  }

  _getCollectors() {
    let serverlessInfo = {};

    if (this.isAWSLambda()) {
      serverlessInfo["function_name"] = process.env.AWS_LAMBDA_FUNCTION_NAME;
      serverlessInfo["aws_region"] = process.env.AWS_REGION;
    } else if (this.isGoogleCloudFunction() || this.isCloudRunOrFirbase()) {
      serverlessInfo["function_name"] = process.env.FUNCTION_NAME || process.env.K_SERVICE;
    } else if (this.isAzureFunction()) {
      serverlessInfo["function_name"] = process.env.WEBSITE_SITE_NAME;
      serverlessInfo["azure_region"] = process.env.REGION_NAME;
    }

    if (serverlessInfo["function_name"] !== undefined) {
      serverlessInfo["rookout_serverless"] = "true";
    }

    return serverlessInfo;
  }

}

class AgentInformation extends Information {
  _getCollectors() {
    return {
      "version": () => new VersionInformation().collect(),
      "network": () => new NetworkInformation().collect(),
      "system": () => new SystemInformation().collect(),
      "platform": () => new PlatformInformation().collect(),
      "scm": () => new SCMInformation().collect(),
      "executable": () => {
        if (process.mainModule !== undefined && process.mainModule.filename !== undefined) {
          return path.basename(process.mainModule.filename);
        } else {
          return path.basename(process.argv[0]);
        }
      },
      "command_arguments": process.argv,
      "process_id": process.pid,
      "cluster": () => new ClusterInformation().collect(),
      "serverless_info": () => new ServerlessInformation().collect()
    };
  }

}

let agentInfoPromise = null;

async function collect(debug, k8sNamespaceFileNameOverride = k8sNamespaceFileName_default) {
  if (!agentInfoPromise) {
    k8sNamespaceFileName = k8sNamespaceFileNameOverride;
    agentInfoPromise = new AgentInformation().collect(debug);
  }

  return agentInfoPromise;
}

function cleanupAgentInfoPromise() {
  if (agentInfoPromise) {
    agentInfoPromise = null;
  }
}

function pack_agent_info(info) {
  let packed_info = new agent_info_pb.AgentInformation();
  packed_info.setAgentId(info.agent_id);
  let version_info = new agent_info_pb.VersionInformation();
  version_info.setVersion(info.version.version);
  version_info.setCommit(info.version.commit);
  packed_info.setVersion(version_info);
  let network_info = new agent_info_pb.NetworkInformation();
  network_info.setIpAddr(info.network.ip_addr);
  network_info.setNetwork(info.network.network);
  packed_info.setNetwork(network_info);
  let system_info = new agent_info_pb.SystemInformation();
  system_info.setHostname(info.system.hostname);
  system_info.setOs(info.system.os);
  system_info.setOsVersion(info.system.os_version);
  system_info.setDistro(info.system.distro);
  system_info.setArch(info.system.arch);
  packed_info.setSystem(system_info);
  let platform_info = new agent_info_pb.PlatformInformation();
  platform_info.setPlatform(info.platform.platform);
  platform_info.setVersion(info.platform.version);
  packed_info.setPlatform(platform_info);
  let scm_info = new agent_info_pb.SCMInformation();
  scm_info.setCommit(info.scm.commit);
  scm_info.setOrigin(info.scm.origin);

  if (info.scm.origin && info.scm.commit) {
    let sourceInfo = new agent_info_pb.SCMInformation.SourceInfo();
    sourceInfo.setRemoteoriginurl(info.scm.origin);
    sourceInfo.setCommit(info.scm.commit);
    scm_info.addSources(sourceInfo);
  }

  Object.keys(info.scm.sources).forEach(origin => {
    let sourceInfo = new agent_info_pb.SCMInformation.SourceInfo();
    sourceInfo.setRemoteoriginurl(origin);
    sourceInfo.setCommit(info.scm.sources[origin]);
    scm_info.addSources(sourceInfo);
  });
  packed_info.setScm(scm_info);
  packed_info.setExecutable(info.executable);
  packed_info.setCommandArgumentsList(info.command_arguments);
  packed_info.setProcessId(info.process_id);
  let labels_map = packed_info.getLabelsMap(); //Add custom labels

  let customLabels = {}; // Add Kubernetes label

  if (info.cluster.k8s_namespace !== "") {
    customLabels["k8s_namespace"] = info.cluster.k8s_namespace;
  } // Add serverless labels


  if (Object.keys(info.serverless_info).length > 0) {
    customLabels = _objectSpread(_objectSpread({}, customLabels), info.serverless_info);
  } //append custom labels if needed


  if (Object.keys(customLabels).length) {
    if (!info.hasOwnProperty('labels')) {
      info.labels = {};
    }

    for (let lbl in customLabels) {
      //add only labels that aren't already set by the user
      if (!info.labels.hasOwnProperty(lbl)) {
        info.labels[lbl] = customLabels[lbl];
      }
    }
  }

  if (info.hasOwnProperty('labels')) {
    Object.keys(info.labels).forEach(key => {
      //set only labels that have values
      if (info.labels[key]) {
        labels_map.set(key, info.labels[key]);
      }
    });
  }

  if (info.debug) {
    labels_map.set("rookout_debug", "on");
  }

  packed_info.setTagsList(info.tags);
  return packed_info;
}