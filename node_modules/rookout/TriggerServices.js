"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("./logger");

var _LoggingService = require("./services/LoggingService");

var _DebuggerService = require("./services/DebuggerService");

var _TracingService = require("./services/TracingService");

var _MemoryUsageLogService = require("./services/MemoryUsageLogService");

var _SystemDataCollector = require("./services/SystemDataCollector");

var _AssertTrackingService = require("./services/AssertTrackingService");

var _AnchorLinesService = require("./services/AnchorLinesService");

const config = require("./config");

class TriggerServices {
  constructor() {
    this.locationServices = {};
    this.collectionServices = {};
    this.loadServices();
  }

  getService(name) {
    return this.locationServices[name] || this.collectionServices[name];
  }

  removeAug(augId) {
    for (let name in this.locationServices) {
      this.locationServices[name].removeAug(augId);
    }
  }

  removeAugfromInspector(augId) {
    for (let name in this.locationServices) {
      this.locationServices[name].removeAugfromInspector(augId);
    }
  }

  reapplyAugAfterTemporaryRemoval(aug) {
    for (let name in this.locationServices) {
      this.locationServices[name].reapplyAugAfterTemporaryRemoval(aug);
    }
  }

  removeAugTemporarily(augId, duration) {
    for (let name in this.locationServices) {
      this.locationServices[name].removeAugTemporarily(augId, duration);
    }
  }

  clearAugs() {
    for (let name of Object.keys(this.locationServices)) {
      this.locationServices[name].clearAugs();
    }
  }

  start() {
    this.loadServices();
  }

  async close() {
    const locationServicesToClose = [...Object.values(this.locationServices)];
    const collectionServicesToClose = [...Object.values(this.collectionServices)];
    this.locationServices = {};
    this.collectionServices = {};

    for (let location_service of locationServicesToClose) {
      await location_service.close();
    }

    for (let collection_service of collectionServicesToClose) {
      collection_service.close();
    }
  }

  loadDebuggerService() {
    try {
      return new _DebuggerService.DebuggerService();
    } catch (e) {
      _logger.logger.exception("Error starting location based services", e);
    }
  }

  loadTracingService() {
    try {
      const tracingService = new _TracingService.TracingService();
      tracingService.start();
      return tracingService;
    } catch (e) {
      console.log("Error starting tracing service", e);
    }
  }

  loadMemoryUsageLogService() {
    if (config.MemoryUsageLogService.ENABLED) {
      try {
        _logger.logger.debug('Starting memory usage log service');

        let memoryUsageLogService = new _MemoryUsageLogService.MemoryUsageLogService();
        memoryUsageLogService.start();
        return memoryUsageLogService;
      } catch (e) {
        _logger.logger.exception("Error starting memory usage log service", e);
      }
    }
  }

  loadSystemDataCollector() {
    if (config.MonitorConfiguration.ENABLED) {
      try {
        _logger.logger.debug('Starting monitor Service');

        let monitorService = new _SystemDataCollector.SystemDataCollector();
        monitorService.start();
        return monitorService;
      } catch (e) {
        _logger.logger.exception("Error starting monitor service", e);
      }
    }
  }

  loadAssertTrackingService() {
    try {
      return new _AssertTrackingService.AssertTrackingService();
    } catch (e) {
      _logger.logger.exception("Error starting assert tracking service " + e.toString());
    }
  }

  loadAnchorLinesService() {
    try {
      return new _AnchorLinesService.AnchorLinesService();
    } catch (e) {
      _logger.logger.exception("Error starting anchor lines service " + e.toString());
    }
  }

  loadLoggingService() {
    if (config.LogHandlerService.ENABLED) {
      try {
        _logger.logger.debug('Starting Logging Service');

        let loggingService = new _LoggingService.LoggingService();
        loggingService.start();
        return loggingService;
      } catch (e) {
        _logger.logger.exception("Error starting logging service", e);
      }
    }
  }

  loadService(service) {
    let serviceHandle = service.func();

    if (serviceHandle === undefined) {
      return;
    }

    if (service.location) {
      this.locationServices[service.name] = serviceHandle;
    } else {
      this.collectionServices[service.name] = serviceHandle;
    }
  }

  loadServices() {
    const services = [{
      'name': 'DebuggerService',
      'func': this.loadDebuggerService,
      'location': true
    }, {
      'name': 'TracingService',
      'func': this.loadTracingService,
      'location': false
    }, {
      'name': 'MemoryUsageLogService',
      'func': this.loadMemoryUsageLogService,
      'location': false
    }, {
      'name': 'MonitorService',
      'func': this.loadSystemDataCollector,
      'location': false
    }, {
      'name': 'AssertTrackingService',
      'func': this.loadAssertTrackingService,
      'location': true
    }, {
      'name': 'AnchorLinesService',
      'func': this.loadAnchorLinesService,
      'location': true
    }, {
      'name': 'loggingService',
      'func': this.loadLoggingService,
      'location': true
    }];

    for (const service of services) {
      this.loadService(service);
    }
  }

}

exports.default = TriggerServices;